<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MULTI TOO HUB</title>
    <style>
        :root {
            --bg-color: #1E1E2F;
            --text-color: #EAEAEA;
            --header-bg: #2B2D42;
            --accent-color: #FFD700;
            --card-bg: #3A3D5B;
            --hover-text: #1E1E2F;
            --hover-accent: #E6C200;
            --shadow: rgba(255, 215, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 20px;
        }

        header {
            background-color: var(--header-bg);
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-color);
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* More responsive grid */
            gap: 20px;
            margin-bottom: 30px;
        }

        .tool-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .tool-card:hover {
            background-color: var(--accent-color);
            color: var(--hover-text);
            transform: translateY(-5px);
            box-shadow: 0 10px 20px var(--shadow);
        }
        .tool-card:hover p, .tool-card:hover h2 {
            color: var(--hover-text);
        }
        .tool-card:hover button {
            background-color: var(--bg-color);
            color: var(--accent-color);
        }


        .tool-card h2 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .tool-card p {
            font-size: 1rem;
            margin-bottom: 15px;
            flex-grow: 1;
        }

        .tool-card button {
            background-color: var(--accent-color);
            color: var(--hover-text);
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            align-self: flex-start;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px 0; /* Add padding for scroll */
        }

        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 1.5rem;
            color: var(--text-color);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: var(--accent-color);
        }

        .tool-container {
            margin-top: 20px;
        }

        .tool-container h2 {
            color: var(--accent-color);
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input, 
        .input-group select, 
        .input-group textarea {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #2B2D42;
            color: var(--text-color);
            font-size: 1rem;
        }
        .input-group input:focus, 
        .input-group select:focus, 
        .input-group textarea:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 5px var(--shadow);
        }


        .input-group input[type="range"] {
            padding: 0;
        }
        .input-group input[type="color"] {
            padding: 2px; /* Minimal padding for color input */
            height: 40px;
        }


        .btn {
            background-color: var(--accent-color);
            color: var(--hover-text);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            margin-right: 5px; /* Added for spacing between buttons */
        }

        .btn:hover {
            background-color: var(--hover-accent);
        }
        .btn:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }

        .btn-copy-small { /* For color picker copy buttons */
            background-color: var(--accent-color);
            color: var(--hover-text);
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 5px;
            transition: background-color 0.3s ease;
        }
        .btn-copy-small:hover {
            background-color: var(--hover-accent);
        }

        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #2B2D42;
            border-radius: 5px;
            word-wrap: break-word;
            /* display: none;  Will be controlled by JS */
        }

        canvas {
            max-width: 100%;
            margin: 10px auto; /* Center canvas if it's smaller than container */
            border-radius: 5px;
            display: block; /* For centering with margin auto */
        }
        #qr-canvas-container { /* For QR code canvas specifically */
             display: flex;
             justify-content: center;
             align-items: center;
             margin: 15px 0;
             border: 1px solid var(--text-color);
             background-color: white; /* QR codes need white background */
             padding: 10px;
             border-radius: 5px;
        }


        .preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 15px 0;
        }

        .range-slider {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .range-slider input[type="range"] {
            flex-grow: 1;
        }

        .range-slider span {
            min-width: 40px;
            text-align: center;
        }

        #ts-laps-list {
            max-height: 150px;
            overflow-y: auto;
            background-color: #2B2D42;
            padding: 10px;
            border-radius: 5px;
            list-style-type: none; /* Remove default bullets */
        }
         #ts-laps-list li {
            padding: 5px 0;
            border-bottom: 1px solid #3A3D5B;
         }
         #ts-laps-list li:last-child {
            border-bottom: none;
         }

        .status-message {
            margin-top: 10px;
            font-style: italic;
        }
        .error-message {
            color: #FF6B6B; /* A light red for errors */
            font-weight: bold;
        }


        @media (max-width: 1024px) {
            /* .tools-grid {
                grid-template-columns: repeat(2, 1fr);
            } */ /* auto-fit handles this better */
        }

        @media (max-width: 600px) {
            /* .tools-grid {
                grid-template-columns: 1fr;
            } */ /* auto-fit handles this */
            h1 { font-size: 2rem; }
            .modal-content {
                width: 95%;
                padding: 20px;
                margin: 20px auto; /* More space on mobile */
            }
            .tool-card h2 { font-size: 1.3rem; }
            .tool-card p { font-size: 0.9rem; }
        }

        /* Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tool-card {
            animation: fadeIn 0.5s ease forwards;
            opacity: 0;
        }

        /* Staggered animation delays for tool cards */
        .tool-card:nth-child(1) { animation-delay: 0.05s; }
        .tool-card:nth-child(2) { animation-delay: 0.1s; }
        .tool-card:nth-child(3) { animation-delay: 0.15s; }
        /* ... and so on for as many cards as you have. This can be automated with JS if many cards. */
        .tool-card:nth-child(4) { animation-delay: 0.2s; }
        .tool-card:nth-child(5) { animation-delay: 0.25s; }
        .tool-card:nth-child(6) { animation-delay: 0.3s; }
        .tool-card:nth-child(7) { animation-delay: 0.35s; }
        .tool-card:nth-child(8) { animation-delay: 0.4s; }
        .tool-card:nth-child(9) { animation-delay: 0.45s; }
        .tool-card:nth-child(10) { animation-delay: 0.5s; }
        .tool-card:nth-child(11) { animation-delay: 0.55s; }
        .tool-card:nth-child(12) { animation-delay: 0.6s; }
        .tool-card:nth-child(13) { animation-delay: 0.65s; }
        .tool-card:nth-child(14) { animation-delay: 0.7s; }
        .tool-card:nth-child(15) { animation-delay: 0.75s; }
        .tool-card:nth-child(16) { animation-delay: 0.8s; }
        .tool-card:nth-child(17) { animation-delay: 0.85s; }
        .tool-card:nth-child(18) { animation-delay: 0.9s; }
        .tool-card:nth-child(19) { animation-delay: 0.95s; }
        .tool-card:nth-child(20) { animation-delay: 1s; }
    </style>
</head>
<body>

<!-- Adsterra Banner Ad: Top Center -->
<div style="text-align: center; margin-bottom: 10px;">
<script type="text/javascript">
	atOptions = {
		'key' : '4008902be030f2ad1be9b584a4903b1e',
		'format' : 'iframe',
		'height' : 50,
		'width' : 320,
		'params' : {}
	};
</script>
<script type="text/javascript" src="//www.highperformanceformat.com/4008902be030f2ad1be9b584a4903b1e/invoke.js"></script>
</div>


    <header>
        <h1>Multi Tool Hub</h1>
        <p>Your all-in-one solution for everyday tools</p>
    </header>

    <div class="tools-grid">
        <!-- Tool Cards -->
        <div class="tool-card" onclick="openTool('image-converter')">
            <h2>Image Converter</h2>
            <p>Convert between JPG, PNG, and WEBP formats (Browser Capabilities)</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('image-compressor')">
            <h2>Image Compressor</h2>
            <p>Compress JPEG image file size with quality settings (Browser Capabilities)</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('image-cropper')">
            <h2>Image Cropper</h2>
            <p>Upload and crop image with preview and export</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('video-converter')">
            <h2>Video Converter</h2>
            <p>Convert video format (Demo Only - Complex)</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('audio-converter')">
            <h2>Audio Converter</h2>
            <p>Convert audio formats (Demo Only - Complex)</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('audio-trimmer')">
            <h2>Audio Trimmer</h2>
            <p>Upload, trim audio, and download as WAV</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('age-calculator')">
            <h2>Age Calculator</h2>
            <p>Calculate age in years, months, and days</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('emi-calculator')">
            <h2>EMI Calculator</h2>
            <p>Calculate monthly EMI and total interest</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('sip-calculator')">
            <h2>SIP Calculator</h2>
            <p>Calculate future value of monthly investments</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('qr-generator')">
            <h2>QR Code Generator</h2>
            <p>Generate scannable QR codes from text/URL</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('password-generator')">
            <h2>Password Generator</h2>
            <p>Generate secure passwords with custom options</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('word-counter')">
            <h2>Word Counter</h2>
            <p>Count words, characters, spaces, and reading time</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('base64-converter')">
            <h2>Base64 Converter</h2>
            <p>Encode and decode text to/from Base64</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('color-picker')">
            <h2>Color Picker</h2>
            <p>Pick colors and get HEX, RGB, HSL values</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('text-to-speech')">
            <h2>Text to Speech</h2>
            <p>Convert text to spoken audio (Browser Dependent)</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('speech-to-text')">
            <h2>Speech to Text</h2>
            <p>Convert voice to text using your microphone (Browser Dependent)</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('json-formatter')">
            <h2>JSON Formatter</h2>
            <p>Format and validate JSON with error handling</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('unit-converter')">
            <h2>Unit Converter</h2>
            <p>Convert between different units of measurement</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('bmi-calculator')">
            <h2>BMI Calculator</h2>
            <p>Calculate BMI and get health category</p>
            <button>Open Tool</button>
        </div>

        <div class="tool-card" onclick="openTool('timer-stopwatch')">
            <h2>Timer / Stopwatch</h2>
            <p>Simple timer and stopwatch functionality</p>
            <button>Open Tool</button>
        </div>
    </div>

    <!-- Modals for each tool (HTML structure remains largely the same as previous version, with minor updates for new features) -->
    <div id="image-converter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('image-converter-modal')">&times;</span>
            <div class="tool-container">
                <h2>Image Converter</h2>
                <p>Convert between JPG, PNG, and WEBP formats (Browser Capabilities)</p>
                <div class="input-group">
                    <label for="ic-image-upload">Upload Image:</label>
                    <input type="file" id="ic-image-upload" accept="image/jpeg,image/png,image/webp,image/gif,image/bmp">
                </div>
                <div class="input-group">
                    <label for="ic-output-format">Output Format:</label>
                    <select id="ic-output-format">
                        <option value="jpeg">JPG</option>
                        <option value="png">PNG</option>
                        <option value="webp">WEBP</option>
                    </select>
                </div>
                <div class="preview-container">
                    <img id="ic-preview" style="max-width: 100%; max-height:300px; display: none;">
                    <canvas id="ic-canvas" style="display: none;"></canvas> <!-- Used for conversion -->
                </div>
                <button id="ic-convert-btn" class="btn">Convert Image</button>
                <div id="ic-result" class="result" style="display: none;">
                    <a id="ic-download-link" href="#" download="converted-image.jpg" class="btn">Download Converted Image</a>
                </div>
                 <p id="ic-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="image-compressor-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('image-compressor-modal')">&times;</span>
            <div class="tool-container">
                <h2>Image Compressor</h2>
                <p>Compress JPEG image file size with quality settings (Browser Capabilities)</p>
                <div class="input-group">
                    <label for="comp-image-upload">Upload Image (JPEG recommended for quality control):</label>
                    <input type="file" id="comp-image-upload" accept="image/jpeg,image/png">
                </div>
                <div class="input-group">
                    <label for="comp-quality">Quality (0-100 for JPEG):</label>
                    <div class="range-slider">
                        <input type="range" id="comp-quality" min="0" max="100" value="80">
                        <span id="comp-quality-value">80</span>
                    </div>
                </div>
                <div class="preview-container">
                     <img id="comp-preview" style="max-width: 100%; max-height:300px; display: none;">
                     <canvas id="comp-canvas" style="display: none;"></canvas> <!-- Used for compression -->
                    <div id="comp-file-size" class="status-message" style="margin-top: 10px;"></div>
                </div>
                <button id="comp-compress-btn" class="btn">Compress Image</button>
                <div id="comp-result" class="result" style="display: none;">
                    <a id="comp-download-link" href="#" download="compressed-image.jpg" class="btn">Download Compressed Image</a>
                </div>
                <p id="comp-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="image-cropper-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('image-cropper-modal')">&times;</span>
            <div class="tool-container">
                <h2>Image Cropper</h2>
                <p>Upload and crop image with preview and export</p>
                <div class="input-group">
                    <label for="crop-image-upload">Upload Image:</label>
                    <input type="file" id="crop-image-upload" accept="image/*">
                </div>
                <div class="preview-container">
                    <canvas id="crop-source-canvas" style="display: none;"></canvas> <!-- Hidden canvas for original image -->
                    <div id="crop-preview-container" style="position: relative; display: none; max-width:100%; max-height: 400px; overflow: hidden; border:1px solid var(--text-color); margin: 0 auto;">
                        <img id="crop-preview-img" style="display: block; max-width:100%; max-height:400px; user-select: none;">
                        <div id="crop-selector" style="position: absolute; border: 2px dashed var(--accent-color); box-sizing: border-box; cursor: move; display: none;">
                           <div class="crop-handle crop-handle-se" style="position:absolute; bottom:-5px; right:-5px; width:10px; height:10px; background:var(--accent-color); cursor:se-resize;"></div>
                           <!-- Add other handles if needed -->
                        </div>
                    </div>
                </div>
                <div id="crop-controls" style="display: none; text-align:center; margin-top:10px;">
                    <!-- Mode buttons removed for simplicity, direct drag/resize on selector -->
                    <button id="crop-execute-btn" class="btn">Crop Image</button>
                    <button id="crop-reset-btn" class="btn">Reset Crop</button>
                </div>
                <div id="crop-result" class="result" style="display: none; text-align:center;">
                    <h4>Cropped Image Preview:</h4>
                    <canvas id="crop-result-canvas" style="max-width: 100%; max-height: 300px; border:1px solid var(--text-color);"></canvas>
                    <a id="crop-download-link" href="#" download="cropped-image.png" class="btn">Download Cropped Image</a>
                </div>
                <p id="crop-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="video-converter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('video-converter-modal')">&times;</span>
            <div class="tool-container">
                <h2>Video Converter</h2>
                <p>Convert video format (Demo Only - Complex functionality typically requires server-side processing or large WebAssembly libraries like ffmpeg.wasm)</p>
                <div class="input-group">
                    <label for="vc-video-upload">Upload Video:</label>
                    <input type="file" id="vc-video-upload" accept="video/*">
                </div>
                <div class="input-group">
                    <label for="vc-output-format">Output Format (Conceptual):</label>
                    <select id="vc-output-format">
                        <option value="mp4">MP4</option>
                        <option value="webm">WebM</option>
                        <option value="gif">Animated GIF (Very Complex)</option>
                    </select>
                </div>
                <div class="preview-container">
                    <video id="vc-preview" controls style="max-width: 100%; display: none;"></video>
                </div>
                <button id="vc-convert-btn" class="btn">Convert Video (Demo)</button>
                <div id="vc-status" class="status-message" style="margin-top: 10px;">Client-side video conversion is highly limited. This is a placeholder.</div>
                <div id="vc-result" class="result" style="display: none;">
                    <a id="vc-download-link" href="#" download="converted-video.mp4" class="btn">Download "Converted" Video (Original)</a>
                </div>
            </div>
        </div>
    </div>

    <div id="audio-converter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('audio-converter-modal')">&times;</span>
            <div class="tool-container">
                <h2>Audio Converter</h2>
                <p>Convert between audio formats (Demo Only - Complex client-side encoding, e.g. to MP3, requires large libraries)</p>
                <div class="input-group">
                    <label for="ac-audio-upload">Upload Audio:</label>
                    <input type="file" id="ac-audio-upload" accept="audio/*">
                </div>
                <div class="input-group">
                    <label for="ac-output-format">Output Format (Conceptual):</label>
                    <select id="ac-output-format">
                        <option value="wav">WAV (Feasible)</option>
                        <option value="mp3">MP3 (Complex)</option>
                        <option value="ogg">OGG (Complex)</option>
                    </select>
                </div>
                <div class="preview-container">
                    <audio id="ac-preview" controls style="max-width: 100%; display: none;"></audio>
                </div>
                <button id="ac-convert-btn" class="btn">Convert Audio (Demo)</button>
                <div id="ac-status" class="status-message" style="margin-top: 10px;">Client-side audio conversion to formats like MP3 is complex. This is a placeholder. WAV output from tools like trimmer is possible.</div>
                <div id="ac-result" class="result" style="display: none;">
                    <a id="ac-download-link" href="#" download="converted-audio.wav" class="btn">Download "Converted" Audio (Original)</a>
                </div>
            </div>
        </div>
    </div>

    <div id="audio-trimmer-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('audio-trimmer-modal')">&times;</span>
            <div class="tool-container">
                <h2>Audio Trimmer</h2>
                <p>Upload, trim audio, and download as WAV</p>
                <div class="input-group">
                    <label for="at-audio-upload">Upload Audio:</label>
                    <input type="file" id="at-audio-upload" accept="audio/*">
                </div>
                <div class="preview-container">
                    <audio id="at-preview" controls style="max-width: 100%; display: none;"></audio>
                    <p id="at-duration-info" class="status-message"></p>
                </div>
                <div id="at-trim-controls" style="display: none;">
                    <div class="input-group">
                        <label for="at-start-time">Start Time (seconds):</label>
                        <input type="number" id="at-start-time" min="0" value="0" step="0.01">
                    </div>
                    <div class="input-group">
                        <label for="at-end-time">End Time (seconds):</label>
                        <input type="number" id="at-end-time" min="0" value="0" step="0.01">
                    </div>
                    <button id="at-trim-btn" class="btn">Trim Audio</button>
                </div>
                <div id="at-status" class="status-message" style="margin-top: 10px;"></div>
                <div id="at-result" class="result" style="display: none;">
                    <h4>Trimmed Audio Preview:</h4>
                    <audio id="at-trimmed-preview" controls style="max-width: 100%;"></audio>
                    <a id="at-download-link" href="#" download="trimmed-audio.wav" class="btn">Download Trimmed WAV</a>
                </div>
            </div>
        </div>
    </div>

    <div id="age-calculator-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('age-calculator-modal')">&times;</span>
            <div class="tool-container">
                <h2>Age Calculator</h2>
                <p>Calculate age in years, months, and days</p>
                <div class="input-group">
                    <label for="ac-birth-date">Date of Birth:</label>
                    <input type="date" id="ac-birth-date">
                </div>
                <div class="input-group">
                    <label for="ac-as-of-date">As of Date (optional, defaults to today):</label>
                    <input type="date" id="ac-as-of-date">
                </div>
                <button id="ac-calculate-btn" class="btn">Calculate Age</button>
                <div id="ac-result" class="result" style="display: none;">
                    <h3>Age Calculation Result</h3>
                    <p id="ac-age-result"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="emi-calculator-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('emi-calculator-modal')">&times;</span>
            <div class="tool-container">
                <h2>EMI Calculator</h2>
                <p>Calculate monthly EMI and total interest</p>
                <div class="input-group">
                    <label for="emi-loan-amount">Loan Amount ($):</label>
                    <input type="number" id="emi-loan-amount" min="1" value="10000" step="any">
                </div>
                <div class="input-group">
                    <label for="emi-interest-rate">Annual Interest Rate (%):</label>
                    <input type="number" id="emi-interest-rate" min="0" max="100" step="0.01" value="7.5">
                </div>
                <div class="input-group">
                    <label for="emi-loan-term">Loan Term (years):</label>
                    <input type="number" id="emi-loan-term" min="0.1" max="50" value="5" step="any">
                </div>
                <button id="emi-calculate-btn" class="btn">Calculate EMI</button>
                <div id="emi-result" class="result" style="display: none;">
                    <h3>EMI Calculation Result</h3>
                    <p id="emi-monthly-payment"></p>
                    <p id="emi-total-interest"></p>
                    <p id="emi-total-payment"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="sip-calculator-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('sip-calculator-modal')">&times;</span>
            <div class="tool-container">
                <h2>SIP Calculator</h2>
                <p>Calculate future value of monthly investments</p>
                <div class="input-group">
                    <label for="sip-monthly-amount">Monthly Investment ($):</label>
                    <input type="number" id="sip-monthly-amount" min="1" value="1000" step="any">
                </div>
                <div class="input-group">
                    <label for="sip-expected-return">Expected Annual Return (%):</label>
                    <input type="number" id="sip-expected-return" min="0" max="100" step="0.01" value="12">
                </div>
                <div class="input-group">
                    <label for="sip-investment-period">Investment Period (years):</label>
                    <input type="number" id="sip-investment-period" min="0.1" max="50" value="10" step="any">
                </div>
                <button id="sip-calculate-btn" class="btn">Calculate SIP</button>
                <div id="sip-result" class="result" style="display: none;">
                    <h3>SIP Calculation Result</h3>
                    <p id="sip-invested-amount"></p>
                    <p id="sip-estimated-returns"></p>
                    <p id="sip-total-value"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="qr-generator-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('qr-generator-modal')">&times;</span>
            <div class="tool-container">
                <h2>QR Code Generator</h2>
                <p>Generate scannable QR codes from text/URL</p>
                <div class="input-group">
                    <label for="qr-content">Content (URL or text):</label>
                    <textarea id="qr-content" rows="3" placeholder="Enter text or URL to encode"></textarea>
                </div>
                <div class="input-group">
                    <label for="qr-size">QR Code Size (pixels):</label>
                     <div class="range-slider">
                        <input type="range" id="qr-size" min="100" max="500" value="256" step="8">
                        <span id="qr-size-value">256</span>
                    </div>
                </div>
                 <div class="input-group">
                    <label for="qr-error-correction">Error Correction Level:</label>
                    <select id="qr-error-correction">
                        <option value="L">Low (L ~7%)</option>
                        <option value="M" selected>Medium (M ~15%)</option>
                        <option value="Q">Quartile (Q ~25%)</option>
                        <option value="H">High (H ~30%)</option>
                    </select>
                </div>
                <button id="qr-generate-btn" class="btn">Generate QR Code</button>
                <div id="qr-result" class="result" style="display: none; text-align: center;">
                    <div id="qr-canvas-container">
                        <canvas id="qr-canvas"></canvas>
                    </div>
                    <a id="qr-download-link" href="#" download="qrcode.png" class="btn">Download QR Code</a>
                </div>
                <p id="qr-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="password-generator-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('password-generator-modal')">&times;</span>
            <div class="tool-container">
                <h2>Password Generator</h2>
                <p>Generate secure passwords with custom options</p>
                <div class="input-group">
                    <label for="pg-length">Password Length:</label>
                    <div class="range-slider">
                        <input type="range" id="pg-length" min="8" max="64" value="16">
                        <span id="pg-length-value">16</span>
                    </div>
                </div>
                <div class="input-group">
                    <label>Character Types:</label>
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <label><input type="checkbox" id="pg-uppercase" checked> Uppercase Letters (A-Z)</label>
                        <label><input type="checkbox" id="pg-lowercase" checked> Lowercase Letters (a-z)</label>
                        <label><input type="checkbox" id="pg-numbers" checked> Numbers (0-9)</label>
                        <label><input type="checkbox" id="pg-symbols" checked> Symbols (!@#$%^&*)</label>
                    </div>
                </div>
                <button id="pg-generate-btn" class="btn">Generate Password</button>
                <div id="pg-result" class="result" style="display: none;">
                    <div class="input-group">
                        <label for="pg-password">Generated Password:</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="pg-password" readonly style="flex-grow: 1;">
                            <button id="pg-copy-btn" class="btn">Copy</button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Password Strength:</label>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <div id="pg-strength-bar" style="height: 10px; background-color: #555; flex-grow: 1; border-radius: 5px;">
                                <div id="pg-strength-progress" style="height: 100%; width: 0%; background-color: red; border-radius: 5px; transition: width 0.3s ease, background-color 0.3s ease;"></div>
                            </div>
                            <span id="pg-strength-text">Weak</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="word-counter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('word-counter-modal')">&times;</span>
            <div class="tool-container">
                <h2>Word Counter</h2>
                <p>Count words, characters, spaces, and reading time</p>
                <div class="input-group">
                    <label for="wc-text">Enter your text:</label>
                    <textarea id="wc-text" rows="10" placeholder="Type or paste your text here..."></textarea>
                </div>
                <div id="wc-stats" class="result" style="display: block;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div><h4>Words:</h4><p id="wc-word-count">0</p></div>
                        <div><h4>Characters:</h4><p id="wc-char-count">0</p></div>
                        <div><h4>Chars (no spaces):</h4><p id="wc-char-no-spaces">0</p></div>
                        <div><h4>Spaces:</h4><p id="wc-space-count">0</p></div>
                        <div><h4>Sentences:</h4><p id="wc-sentence-count">0</p></div>
                        <div><h4>Paragraphs:</h4><p id="wc-paragraph-count">0</p></div>
                        <div><h4>Reading Time:</h4><p id="wc-reading-time">0 minutes</p></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="base64-converter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('base64-converter-modal')">&times;</span>
            <div class="tool-container">
                <h2>Base64 Converter</h2>
                <p>Encode and decode text to/from Base64 (UTF-8 Safe)</p>
                <div class="input-group">
                    <label for="b64-direction">Conversion Direction:</label>
                    <select id="b64-direction">
                        <option value="encode">Text to Base64</option>
                        <option value="decode">Base64 to Text</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="b64-input">Input:</label>
                    <textarea id="b64-input" rows="5" placeholder="Enter text to encode or Base64 to decode"></textarea>
                </div>
                <button id="b64-convert-btn" class="btn">Convert</button>
                <div id="b64-result" class="result" style="display: none;">
                    <div class="input-group">
                        <label for="b64-output">Result:</label>
                        <textarea id="b64-output" rows="5" readonly></textarea>
                    </div>
                    <button id="b64-copy-btn" class="btn">Copy to Clipboard</button>
                </div>
                 <p id="b64-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="color-picker-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('color-picker-modal')">&times;</span>
            <div class="tool-container">
                <h2>Color Picker</h2>
                <p>Pick colors and get HEX, RGB, HSL values</p>
                <div class="input-group">
                    <label for="cp-color-input">Choose Color:</label>
                    <input type="color" id="cp-color-input" value="#FFD700">
                </div>
                <div id="cp-preview" style="width: 100px; height: 100px; border: 1px solid var(--text-color); margin: 10px auto; background-color: #FFD700; border-radius: 5px;"></div>
                <div id="cp-result" class="result" style="display: block;">
                    <p>HEX: <input type="text" id="cp-hex-value-input" readonly style="width:auto; display:inline-block; margin-right:5px;"> <button class="btn-copy-small" onclick="copyToClipboardCP('cp-hex-value-input', true)">Copy</button></p>
                    <p>RGB: <input type="text" id="cp-rgb-value-input" readonly style="width:auto; display:inline-block; margin-right:5px;"> <button class="btn-copy-small" onclick="copyToClipboardCP('cp-rgb-value-input', true)">Copy</button></p>
                    <p>HSL: <input type="text" id="cp-hsl-value-input" readonly style="width:auto; display:inline-block; margin-right:5px;"> <button class="btn-copy-small" onclick="copyToClipboardCP('cp-hsl-value-input', true)">Copy</button></p>
                </div>
            </div>
        </div>
    </div>

    <div id="text-to-speech-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('text-to-speech-modal')">&times;</span>
            <div class="tool-container">
                <h2>Text to Speech</h2>
                <p>Convert text to spoken audio (Browser Dependent)</p>
                <div class="input-group">
                    <label for="tts-text">Text to speak:</label>
                    <textarea id="tts-text" rows="5" placeholder="Enter text here..."></textarea>
                </div>
                <div class="input-group">
                    <label for="tts-voice">Voice:</label>
                    <select id="tts-voice" disabled><option>Loading voices...</option></select>
                </div>
                <div class="input-group">
                    <label for="tts-rate">Rate (0.5 - 2):</label>
                    <div class="range-slider">
                        <input type="range" id="tts-rate" min="0.5" max="2" value="1" step="0.1">
                        <span id="tts-rate-value">1</span>
                    </div>
                </div>
                <div class="input-group">
                    <label for="tts-pitch">Pitch (0 - 2):</label>
                    <div class="range-slider">
                        <input type="range" id="tts-pitch" min="0" max="2" value="1" step="0.1">
                        <span id="tts-pitch-value">1</span>
                    </div>
                </div>
                <button id="tts-speak-btn" class="btn" disabled>Speak</button>
                <button id="tts-pause-btn" class="btn" disabled>Pause</button>
                <button id="tts-resume-btn" class="btn" disabled>Resume</button>
                <button id="tts-stop-btn" class="btn" disabled>Stop</button>
                <p id="tts-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="speech-to-text-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('speech-to-text-modal')">&times;</span>
            <div class="tool-container">
                <h2>Speech to Text</h2>
                <p>Convert voice to text using your microphone (Browser Dependent)</p>
                <button id="stt-start-btn" class="btn">Start Listening</button>
                <button id="stt-stop-btn" class="btn" style="display:none;">Stop Listening</button>
                <div class="input-group" style="margin-top:15px;">
                    <label for="stt-output">Recognized Text:</label>
                    <textarea id="stt-output" rows="5" readonly placeholder="Recognized text will appear here..."></textarea>
                </div>
                <p id="stt-status" class="status-message"></p>
            </div>
        </div>
    </div>

    <div id="json-formatter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('json-formatter-modal')">&times;</span>
            <div class="tool-container">
                <h2>JSON Formatter & Validator</h2>
                <p>Format and validate JSON with error handling</p>
                <div class="input-group">
                    <label for="jsonf-input">Input JSON:</label>
                    <textarea id="jsonf-input" rows="8" placeholder="Paste your JSON here..."></textarea>
                </div>
                <button id="jsonf-format-btn" class="btn">Format & Validate</button>
                 <button id="jsonf-minify-btn" class="btn">Minify</button>
                <div id="jsonf-result" class="result" style="display: none;">
                    <label for="jsonf-output">Output:</label>
                    <textarea id="jsonf-output" rows="8" readonly></textarea>
                    <button id="jsonf-copy-btn" class="btn">Copy Output</button>
                </div>
                <p id="jsonf-error" class="status-message error-message"></p>
            </div>
        </div>
    </div>

    <div id="unit-converter-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('unit-converter-modal')">&times;</span>
            <div class="tool-container">
                <h2>Unit Converter</h2>
                <p>Convert between different units of measurement</p>
                <div class="input-group">
                    <label for="uc-category">Category:</label>
                    <select id="uc-category">
                        <option value="length">Length</option>
                        <option value="temperature">Temperature</option>
                        <option value="weight">Weight/Mass</option>
                        <option value="area">Area</option>
                        <option value="volume">Volume</option>
                        <option value="speed">Speed</option>
                        <option value="time">Time</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px; align-items:center;">
                    <div class="input-group" style="flex:2;">
                        <label for="uc-input-value">Value:</label>
                        <input type="number" id="uc-input-value" placeholder="Enter value" step="any">
                    </div>
                    <div class="input-group" style="flex:3;">
                        <label for="uc-from-unit">From:</label>
                        <select id="uc-from-unit"></select>
                    </div>
                     <span style="font-size:1.5rem; margin: 0 5px; padding-top:20px;">→</span>
                    <div class="input-group" style="flex:3;">
                        <label for="uc-to-unit">To:</label>
                        <select id="uc-to-unit"></select>
                    </div>
                </div>
                <button id="uc-convert-btn" class="btn">Convert</button>
                <div id="uc-result" class="result" style="display: none;">
                    <p id="uc-result-text"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="bmi-calculator-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('bmi-calculator-modal')">&times;</span>
            <div class="tool-container">
                <h2>BMI Calculator</h2>
                <p>Calculate BMI and get health category</p>
                <div class="input-group">
                    <label for="bmi-height">Height (cm):</label>
                    <input type="number" id="bmi-height" placeholder="e.g., 175" min="1">
                </div>
                <div class="input-group">
                    <label for="bmi-weight">Weight (kg):</label>
                    <input type="number" id="bmi-weight" placeholder="e.g., 70" min="1">
                </div>
                <button id="bmi-calculate-btn" class="btn">Calculate BMI</button>
                <div id="bmi-result" class="result" style="display: none;">
                    <p id="bmi-value-text"></p>
                    <p id="bmi-category-text"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="timer-stopwatch-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal('timer-stopwatch-modal')">&times;</span>
            <div class="tool-container">
                <h2>Timer / Stopwatch</h2>
                <div style="display: flex; justify-content: space-around; margin-bottom: 20px; border-bottom: 1px solid var(--header-bg); padding-bottom: 10px;">
                    <button id="ts-show-timer-btn" class="btn">Timer</button>
                    <button id="ts-show-stopwatch-btn" class="btn">Stopwatch</button>
                </div>

                <!-- Timer Section -->
                <div id="ts-timer-section" style="display: none;">
                    <h3>Timer</h3>
                    <div class="input-group">
                        <label for="ts-timer-hours">Hours:</label>
                        <input type="number" id="ts-timer-hours" min="0" max="99" value="0">
                    </div>
                    <div class="input-group">
                        <label for="ts-timer-minutes">Minutes:</label>
                        <input type="number" id="ts-timer-minutes" min="0" max="59" value="5">
                    </div>
                    <div class="input-group">
                        <label for="ts-timer-seconds">Seconds:</label>
                        <input type="number" id="ts-timer-seconds" min="0" max="59" value="0">
                    </div>
                    <div id="ts-timer-display" style="font-size: 2.5rem; text-align: center; margin: 10px 0; color:var(--accent-color);">00:05:00</div>
                    <div style="text-align:center;">
                        <button id="ts-timer-start-btn" class="btn">Start</button>
                        <button id="ts-timer-pause-btn" class="btn" disabled>Pause</button>
                        <button id="ts-timer-reset-btn" class="btn">Reset</button>
                    </div>
                </div>

                <!-- Stopwatch Section -->
                <div id="ts-stopwatch-section" style="display: block;"> <!-- Default visible -->
                    <h3>Stopwatch</h3>
                    <div id="ts-stopwatch-display" style="font-size: 2.5rem; text-align: center; margin: 20px 0; color:var(--accent-color);">00:00:00.00</div>
                     <div style="text-align:center;">
                        <button id="ts-stopwatch-start-btn" class="btn">Start</button>
                        <button id="ts-stopwatch-stop-btn" class="btn" disabled>Stop</button>
                        <button id="ts-stopwatch-reset-btn" class="btn">Reset</button>
                    </div>
                    <div id="ts-laps-container" style="margin-top: 15px;">
                        <button id="ts-stopwatch-lap-btn" class="btn" disabled>Lap</button>
                        <h4>Laps:</h4>
                        <ul id="ts-laps-list"></ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    // Global variables
    let currentModal = null;
    // Image Cropper State (simplified, more in its init)
    let cropper = {
        active: false,
        img: null,
        selector: null,
        previewContainer: null,
        sourceCanvas: null,
        resultCanvas: null,
        downloadLink: null,
        startX: 0, startY: 0,
        currentX: 0, currentY: 0,
        cropWidth: 100, cropHeight: 100,
        isDragging: false, isResizing: false,
        scaleX: 1, scaleY: 1
    };


    // State variables for tools
    let recognition = null; 
    let sttIsListening = false;
    let ttsVoices = []; 
    let ttsUtterance = null;

    let timerInterval = null;
    let timerTotalSeconds = 0;
    let timerRunning = false;

    let stopwatchInterval = null;
    let stopwatchStartTime = 0;
    let stopwatchElapsedTime = 0;
    let stopwatchRunning = false;
    let stopwatchLaps = [];

    let audioContext = null; // For Audio Trimmer
    let originalAudioBuffer = null; // For Audio Trimmer


    // Modal functions
    function openTool(toolId) {
        const modalId = `${toolId}-modal`;
        currentModal = document.getElementById(modalId);
        if (currentModal) {
            currentModal.style.display = 'block';
            document.body.style.overflow = 'hidden';
            resetToolState(toolId); 
        }
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
            
            if (modalId === 'speech-to-text-modal' && recognition && sttIsListening) {
                recognition.stop();
            }
            if (modalId === 'text-to-speech-modal' && typeof speechSynthesis !== 'undefined' && speechSynthesis.speaking) {
                speechSynthesis.cancel();
                if (ttsUtterance) ttsUtterance.onend = null; // Clear onend handler
            }
            if (modalId === 'timer-stopwatch-modal') {
                if (timerInterval) clearInterval(timerInterval);
                timerRunning = false;
                if (stopwatchInterval) clearInterval(stopwatchInterval);
                stopwatchRunning = false;
            }
            if (modalId === 'image-cropper-modal' && cropper.active) {
                // Clean up cropper listeners if any were added to document
                document.removeEventListener('mousemove', cropper.handleMouseMove);
                document.removeEventListener('mouseup', cropper.handleMouseUp);
                cropper.active = false;
            }
            currentModal = null;
        }
    }
    
    function showStatus(toolId, message, isError = false) {
        const statusEl = document.getElementById(`${toolId}-status`);
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.className = `status-message ${isError ? 'error-message' : ''}`;
        }
    }


    function resetToolState(toolId) {
        // Clear general status messages
        const statusEl = document.getElementById(`${toolId}-status`);
        if (statusEl) statusEl.textContent = '';
        const errorEl = document.getElementById(`${toolId}-error`);
        if (errorEl) errorEl.textContent = '';

        // Tool-specific resets
        if (toolId === 'image-converter') {
            document.getElementById('ic-image-upload').value = '';
            document.getElementById('ic-preview').style.display = 'none';
            document.getElementById('ic-preview').src = '#';
            document.getElementById('ic-result').style.display = 'none';
        } else if (toolId === 'image-compressor') {
            document.getElementById('comp-image-upload').value = '';
            document.getElementById('comp-preview').style.display = 'none';
            document.getElementById('comp-preview').src = '#';
            document.getElementById('comp-file-size').textContent = '';
            document.getElementById('comp-result').style.display = 'none';
            document.getElementById('comp-quality').value = 80;
            document.getElementById('comp-quality-value').textContent = '80';
        } else if (toolId === 'image-cropper') {
            initImageCropper(); // Re-initialize to reset its internal state management
        } else if (toolId === 'audio-trimmer') {
            document.getElementById('at-audio-upload').value = '';
            document.getElementById('at-preview').style.display = 'none';
            document.getElementById('at-preview').src = '#';
            document.getElementById('at-duration-info').textContent = '';
            document.getElementById('at-trim-controls').style.display = 'none';
            document.getElementById('at-result').style.display = 'none';
            originalAudioBuffer = null;
        } else if (toolId === 'qr-generator') {
            document.getElementById('qr-content').value = '';
            const qrCanvas = document.getElementById('qr-canvas');
            const ctx = qrCanvas.getContext('2d');
            ctx.clearRect(0, 0, qrCanvas.width, qrCanvas.height);
            document.getElementById('qr-result').style.display = 'none';
            document.getElementById('qr-size').value = 256;
            document.getElementById('qr-size-value').textContent = '256';
        } else if (toolId === 'color-picker') {
            const cpColorInput = document.getElementById('cp-color-input');
            if (cpColorInput) {
                 cpColorInput.value = '#FFD700';
                 cpColorInput.dispatchEvent(new Event('input'));
            }
        } else if (toolId === 'text-to-speech') {
            if (typeof speechSynthesis !== 'undefined' && speechSynthesis.speaking) speechSynthesis.cancel();
            document.getElementById('tts-text').value = '';
            document.getElementById('tts-speak-btn').disabled = true; // Will be enabled when voices load
            document.getElementById('tts-pause-btn').disabled = true;
            document.getElementById('tts-resume-btn').disabled = true;
            document.getElementById('tts-stop-btn').disabled = true;
            document.getElementById('tts-status').textContent = '';
            // initTextToSpeech handles voice population and button enablement
        } else if (toolId === 'speech-to-text') {
            document.getElementById('stt-output').value = '';
            document.getElementById('stt-status').textContent = 'Click "Start Listening" to begin.';
            document.getElementById('stt-start-btn').style.display = 'inline-block';
            document.getElementById('stt-stop-btn').style.display = 'none';
            if (recognition && sttIsListening) recognition.stop();
        } else if (toolId === 'json-formatter') {
            document.getElementById('jsonf-input').value = '';
            document.getElementById('jsonf-output').value = '';
            document.getElementById('jsonf-result').style.display = 'none';
            document.getElementById('jsonf-error').textContent = '';
        } else if (toolId === 'unit-converter') {
            document.getElementById('uc-input-value').value = '';
            document.getElementById('uc-result').style.display = 'none';
            const ucCategory = document.getElementById('uc-category');
            if(ucCategory) {
                ucCategory.value = 'length'; 
                ucCategory.dispatchEvent(new Event('change')); // This will call populateUnits
            }
        } else if (toolId === 'bmi-calculator') {
            document.getElementById('bmi-height').value = '';
            document.getElementById('bmi-weight').value = '';
            document.getElementById('bmi-result').style.display = 'none';
        } else if (toolId === 'timer-stopwatch') {
            clearInterval(timerInterval);
            timerRunning = false;
            document.getElementById('ts-timer-hours').value = "0";
            document.getElementById('ts-timer-minutes').value = "5";
            document.getElementById('ts-timer-seconds').value = "0";
            document.getElementById('ts-timer-display').textContent = "00:05:00";
            ['ts-timer-hours', 'ts-timer-minutes', 'ts-timer-seconds'].forEach(id => document.getElementById(id).disabled = false);
            document.getElementById('ts-timer-start-btn').disabled = false;
            document.getElementById('ts-timer-pause-btn').disabled = true;

            clearInterval(stopwatchInterval);
            stopwatchRunning = false;
            stopwatchElapsedTime = 0;
            stopwatchLaps = [];
            document.getElementById('ts-stopwatch-display').textContent = "00:00:00.00";
            document.getElementById('ts-laps-list').innerHTML = '';
            document.getElementById('ts-stopwatch-start-btn').disabled = false;
            document.getElementById('ts-stopwatch-stop-btn').disabled = true;
            document.getElementById('ts-stopwatch-lap-btn').disabled = true;

            document.getElementById('ts-stopwatch-section').style.display = 'block';
            document.getElementById('ts-timer-section').style.display = 'none';
        }
    }


    // Close modal when clicking outside content
    window.onclick = function(event) {
        if (event.target.classList.contains('modal')) {
            closeModal(event.target.id); 
        }
    };

    // Initialize all tools when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        initImageConverter();
        initImageCompressor();
        initImageCropper(); 
        initVideoConverter();
        initAudioConverter();
        initAudioTrimmer();
        initAgeCalculator();
        initEMICalculator();
        initSIPCalculator();
        initQRGenerator();
        initPasswordGenerator();
        initWordCounter();
        initBase64Converter();
        initColorPicker();
        initTextToSpeech();
        initSpeechToText();
        initJSONFormatter();
        initUnitConverter();
        initBMICalculator();
        initTimerStopwatch();

        // Initialize AudioContext globally if possible (some browsers require user interaction first)
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn("Web Audio API could not be initialized on load. May require user interaction.");
        }
    });

    // ===================== TOOL IMPLEMENTATIONS =====================

    // 1. Image Converter 
    function initImageConverter() {
        const uploadInput = document.getElementById('ic-image-upload');
        const formatSelect = document.getElementById('ic-output-format');
        const convertBtn = document.getElementById('ic-convert-btn');
        const canvas = document.getElementById('ic-canvas'); // For conversion
        const preview = document.getElementById('ic-preview');
        const resultDiv = document.getElementById('ic-result');
        const downloadLink = document.getElementById('ic-download-link');
        const statusEl = document.getElementById('ic-status');
        let originalFileName = 'image';

        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                originalFileName = file.name.split('.')[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    preview.src = event.target.result;
                    preview.style.display = 'block';
                    canvas.style.display = 'none';
                    resultDiv.style.display = 'none';
                    statusEl.textContent = `Loaded: ${file.name}`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.style.display = 'none';
                statusEl.textContent = '';
            }
        });

        convertBtn.addEventListener('click', function() {
            if (!uploadInput.files[0]) {
                showStatus('ic', 'Please upload an image first.', true);
                return;
            }
            statusEl.textContent = 'Converting...';
            const file = uploadInput.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    canvas.width = img.naturalWidth; // Use natural dimensions for quality
                    canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    const format = formatSelect.value;
                    let mimeType = `image/${format}`;
                    if (format === 'jpg') mimeType = 'image/jpeg'; // Common alias
                    
                    try {
                        const dataURL = canvas.toDataURL(mimeType, 0.92); // 0.92 quality for lossy formats
                        downloadLink.href = dataURL;
                        downloadLink.download = `${originalFileName}-converted.${format}`;
                        resultDiv.style.display = 'block';
                        statusEl.textContent = 'Conversion successful!';
                    } catch (err) {
                        showStatus('ic', `Error during conversion: ${err.message}. Format might not be supported for export by your browser.`, true);
                        console.error("Conversion error:", err);
                        resultDiv.style.display = 'none';
                    }
                };
                img.onerror = function() {
                    showStatus('ic', 'Could not load the uploaded image. It might be corrupt or an unsupported format.', true);
                     resultDiv.style.display = 'none';
                }
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    // 2. Image Compressor
    function initImageCompressor() {
        const uploadInput = document.getElementById('comp-image-upload');
        const qualitySlider = document.getElementById('comp-quality');
        const qualityValue = document.getElementById('comp-quality-value');
        const compressBtn = document.getElementById('comp-compress-btn');
        const canvas = document.getElementById('comp-canvas'); 
        const preview = document.getElementById('comp-preview');
        const fileSizeSpan = document.getElementById('comp-file-size');
        const resultDiv = document.getElementById('comp-result');
        const downloadLink = document.getElementById('comp-download-link');
        const statusEl = document.getElementById('comp-status');
        let originalFileSize = 0;
        let originalFileName = 'image';
        let originalFileType = 'image/jpeg';


        qualitySlider.addEventListener('input', function() {
            qualityValue.textContent = this.value;
        });

        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                originalFileSize = file.size;
                originalFileName = file.name.split('.')[0];
                originalFileType = file.type;
                fileSizeSpan.textContent = `Original size: ${formatFileSize(file.size)}`;
                const reader = new FileReader();
                reader.onload = function(event) {
                    preview.src = event.target.result;
                    preview.style.display = 'block';
                    resultDiv.style.display = 'none';
                    statusEl.textContent = `Loaded: ${file.name}`;
                };
                reader.readAsDataURL(file);
            } else {
                 preview.style.display = 'none';
                 fileSizeSpan.textContent = '';
                 statusEl.textContent = '';
            }
        });

        compressBtn.addEventListener('click', function() {
            if (!uploadInput.files[0]) {
                showStatus('comp', 'Please upload an image first.', true);
                return;
            }
            statusEl.textContent = 'Compressing...';

            const file = uploadInput.files[0];
            const quality = parseInt(qualitySlider.value) / 100; 
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    let outputMimeType = 'image/jpeg'; // Default to JPEG for quality-based compression
                    let outputExtension = 'jpg';

                    // If original is PNG and quality is 100%, consider keeping PNG (though canvas PNG is lossless)
                    // However, for "compression" task, JPEG is usually implied for lossy size reduction.
                    // If originalFileType is PNG, and user wants to compress, it usually means converting to JPEG or WEBP.
                    // For simplicity, this tool will primarily compress to JPEG using the quality slider.
                    // if (originalFileType === 'image/png' && quality === 1) {
                    //    outputMimeType = 'image/png'; outputExtension = 'png';
                    // }

                    canvas.toBlob(function(blob) {
                        if (blob) {
                            const compressedUrl = URL.createObjectURL(blob);
                            downloadLink.href = compressedUrl;
                            downloadLink.download = `${originalFileName}-compressed.${outputExtension}`;
                            
                            let reductionText = '';
                            if (originalFileSize > 0 && blob.size < originalFileSize) {
                                reductionText = `<br>Reduction: ${Math.round((1 - blob.size/originalFileSize) * 100)}%`;
                            } else if (originalFileSize > 0 && blob.size >= originalFileSize) {
                                reductionText = `<br>No size reduction (or larger). Try lower quality or different format.`;
                            }

                            fileSizeSpan.innerHTML = `Original size: ${formatFileSize(originalFileSize)}<br>
                                                    Compressed size: ${formatFileSize(blob.size)}${reductionText}`;
                            resultDiv.style.display = 'block';
                            statusEl.textContent = 'Compression successful!';
                        } else {
                            showStatus('comp', 'Error during compression. The browser might not support the operation for this image type/size.', true);
                        }
                    }, outputMimeType, quality);
                };
                img.onerror = function() {
                    showStatus('comp', 'Could not load the uploaded image.', true);
                }
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    // 3. Image Cropper 
    function initImageCropper() {
        cropper.img = document.getElementById('crop-preview-img');
        cropper.selector = document.getElementById('crop-selector');
        cropper.previewContainer = document.getElementById('crop-preview-container');
        cropper.sourceCanvas = document.getElementById('crop-source-canvas');
        cropper.resultCanvas = document.getElementById('crop-result-canvas');
        cropper.downloadLink = document.getElementById('crop-download-link');
        const uploadInput = document.getElementById('crop-image-upload');
        const executeBtn = document.getElementById('crop-execute-btn');
        const resetBtn = document.getElementById('crop-reset-btn');
        const controlsDiv = document.getElementById('crop-controls');
        const resultDiv = document.getElementById('crop-result');
        const statusEl = document.getElementById('crop-status');
        let originalImageObject = null; // Store the actual Image() object
        let originalFileName = 'image';

        // Reset cropper UI
        cropper.img.style.display = 'none';
        cropper.previewContainer.style.display = 'none';
        cropper.selector.style.display = 'none';
        controlsDiv.style.display = 'none';
        resultDiv.style.display = 'none';
        uploadInput.value = '';
        statusEl.textContent = '';
        cropper.active = false;


        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                originalFileName = file.name.split('.')[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    originalImageObject = new Image();
                    originalImageObject.onload = () => {
                        cropper.img.src = event.target.result;
                        cropper.img.style.display = 'block';
                        cropper.previewContainer.style.display = 'block'; // Show container AFTER image is loaded to get dimensions
                        controlsDiv.style.display = 'block';
                        resultDiv.style.display = 'none';
                        statusEl.textContent = `Loaded: ${file.name}. Drag to move, drag corner to resize.`;

                        // Draw to source canvas at natural size
                        cropper.sourceCanvas.width = originalImageObject.naturalWidth;
                        cropper.sourceCanvas.height = originalImageObject.naturalHeight;
                        cropper.sourceCanvas.getContext('2d').drawImage(originalImageObject, 0, 0);
                        
                        resetCropperSelection();
                        cropper.active = true;
                    };
                    originalImageObject.onerror = () => showStatus('crop', 'Could not load image file.', true);
                    originalImageObject.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        function resetCropperSelection() {
            if (!cropper.img.offsetWidth || !cropper.img.offsetHeight) { // Image not displayed yet
                 setTimeout(resetCropperSelection, 50); // Retry shortly
                 return;
            }
            const previewWidth = cropper.img.offsetWidth;
            const previewHeight = cropper.img.offsetHeight;

            cropper.cropWidth = previewWidth * 0.6;
            cropper.cropHeight = previewHeight * 0.6;
            cropper.currentX = (previewWidth - cropper.cropWidth) / 2;
            cropper.currentY = (previewHeight - cropper.cropHeight) / 2;
            updateSelectorStyle();
            cropper.selector.style.display = 'block';
        }

        function updateSelectorStyle() {
            cropper.selector.style.left = `${cropper.currentX}px`;
            cropper.selector.style.top = `${cropper.currentY}px`;
            cropper.selector.style.width = `${cropper.cropWidth}px`;
            cropper.selector.style.height = `${cropper.cropHeight}px`;
        }

        cropper.selector.addEventListener('mousedown', function(e) {
            if (!cropper.active) return;
            e.preventDefault(); // Prevent image dragging issues
            cropper.isDragging = true;
            
            const handle = e.target.closest('.crop-handle');
            if (handle) {
                cropper.isResizing = handle.classList.contains('crop-handle-se') ? 'se' : true; // Add more handles
                cropper.isDragging = false; // Not dragging the whole selector
            }

            cropper.startX = e.clientX;
            cropper.startY = e.clientY;
            cropper.initialX = cropper.currentX;
            cropper.initialY = cropper.currentY;
            cropper.initialWidth = cropper.cropWidth;
            cropper.initialHeight = cropper.cropHeight;
            
            document.addEventListener('mousemove', cropper.handleMouseMove);
            document.addEventListener('mouseup', cropper.handleMouseUp);
        });

        cropper.handleMouseMove = function(e) {
            if (!cropper.active) return;
            const dx = e.clientX - cropper.startX;
            const dy = e.clientY - cropper.startY;
            const previewWidth = cropper.img.offsetWidth;
            const previewHeight = cropper.img.offsetHeight;

            if (cropper.isDragging) {
                cropper.currentX = Math.max(0, Math.min(cropper.initialX + dx, previewWidth - cropper.cropWidth));
                cropper.currentY = Math.max(0, Math.min(cropper.initialY + dy, previewHeight - cropper.cropHeight));
            } else if (cropper.isResizing) {
                if (cropper.isResizing === 'se') { // South-East resize
                    cropper.cropWidth = Math.max(20, Math.min(cropper.initialWidth + dx, previewWidth - cropper.currentX));
                    cropper.cropHeight = Math.max(20, Math.min(cropper.initialHeight + dy, previewHeight - cropper.currentY));
                }
                // Add logic for other handles if implemented
            }
            updateSelectorStyle();
        }

        cropper.handleMouseUp = function() {
            if (!cropper.active) return;
            cropper.isDragging = false;
            cropper.isResizing = false;
            document.removeEventListener('mousemove', cropper.handleMouseMove);
            document.removeEventListener('mouseup', cropper.handleMouseUp);
        }
        
        resetBtn.addEventListener('click', () => {
            if (cropper.img.src && cropper.img.src !== '#' && originalImageObject) {
                 resetCropperSelection();
                 resultDiv.style.display = 'none';
                 statusEl.textContent = 'Crop selection reset.';
            } else {
                showStatus('crop', 'Upload an image first to reset crop.', true);
            }
        });

        executeBtn.addEventListener('click', function() {
            if (!originalImageObject || !cropper.active) {
                showStatus('crop', 'Please upload an image and make a selection first.', true);
                return;
            }
            statusEl.textContent = 'Cropping...';

            const scaleX = originalImageObject.naturalWidth / cropper.img.offsetWidth;
            const scaleY = originalImageObject.naturalHeight / cropper.img.offsetHeight;

            const sX = cropper.currentX * scaleX;
            const sY = cropper.currentY * scaleY;
            const sWidth = cropper.cropWidth * scaleX;
            const sHeight = cropper.cropHeight * scaleY;

            if (sWidth <= 0 || sHeight <= 0) {
                showStatus('crop', 'Invalid crop dimensions. Please make a valid selection.', true);
                return;
            }

            cropper.resultCanvas.width = sWidth;
            cropper.resultCanvas.height = sHeight;
            const ctx = cropper.resultCanvas.getContext('2d');
            ctx.drawImage(cropper.sourceCanvas, sX, sY, sWidth, sHeight, 0, 0, sWidth, sHeight);
            
            const outputFormat = 'image/png'; // Default to PNG for cropper for lossless
            const outputExtension = 'png';
            cropper.downloadLink.href = cropper.resultCanvas.toDataURL(outputFormat);
            cropper.downloadLink.download = `${originalFileName}-cropped.${outputExtension}`;
            
            resultDiv.style.display = 'block';
            statusEl.textContent = 'Image cropped successfully!';
        });
    }

    // 4. Video Converter (Demo)
    function initVideoConverter() {
        const uploadInput = document.getElementById('vc-video-upload');
        const formatSelect = document.getElementById('vc-output-format');
        const convertBtn = document.getElementById('vc-convert-btn');
        const preview = document.getElementById('vc-preview');
        const statusDiv = document.getElementById('vc-status');
        const resultDiv = document.getElementById('vc-result');
        const downloadLink = document.getElementById('vc-download-link');
        let originalFileName = "video";

        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                originalFileName = file.name.split('.')[0];
                preview.src = URL.createObjectURL(file);
                preview.style.display = 'block';
                statusDiv.textContent = `Loaded: ${file.name} (${formatFileSize(file.size)}). ${statusDiv.dataset.defaultMessage || ""}`;
                resultDiv.style.display = 'none';
            }
        });
        statusDiv.dataset.defaultMessage = statusDiv.textContent; // Store initial message

        convertBtn.addEventListener('click', function() {
            if (!uploadInput.files[0]) {
                statusDiv.textContent = 'Please upload a video first. ' + (statusDiv.dataset.defaultMessage || "");
                return;
            }
            const selectedFormat = formatSelect.value;
            statusDiv.textContent = `Simulating conversion to ${selectedFormat.toUpperCase()}... This is a demo. Real conversion is complex.`;
            
            setTimeout(function() {
                statusDiv.textContent = `Demo "conversion" to ${selectedFormat.toUpperCase()} complete. Download link provides original file.`;
                if (preview.src) { 
                    downloadLink.href = preview.src; 
                    downloadLink.download = `${originalFileName}-converted-demo.${selectedFormat}`;
                    resultDiv.style.display = 'block';
                } else {
                     statusDiv.textContent = 'Error: No video loaded for demo conversion.';
                }
            }, 1500);
        });
    }

    // 5. Audio Converter (Demo)
    function initAudioConverter() {
        const uploadInput = document.getElementById('ac-audio-upload');
        const formatSelect = document.getElementById('ac-output-format');
        const convertBtn = document.getElementById('ac-convert-btn');
        const preview = document.getElementById('ac-preview');
        const statusDiv = document.getElementById('ac-status');
        const resultDiv = document.getElementById('ac-result');
        const downloadLink = document.getElementById('ac-download-link');
        let originalFileName = "audio";

        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                originalFileName = file.name.split('.')[0];
                preview.src = URL.createObjectURL(file);
                preview.style.display = 'block';
                statusDiv.textContent = `Loaded: ${file.name} (${formatFileSize(file.size)}). ${statusDiv.dataset.defaultMessage || ""}`;
                resultDiv.style.display = 'none';
            }
        });
        statusDiv.dataset.defaultMessage = statusDiv.textContent;

        convertBtn.addEventListener('click', function() {
            if (!uploadInput.files[0]) {
                statusDiv.textContent = 'Please upload an audio file first. ' + (statusDiv.dataset.defaultMessage || "");
                return;
            }
            const selectedFormat = formatSelect.value;
             statusDiv.textContent = `Simulating conversion to ${selectedFormat.toUpperCase()}... This is a demo. Real conversion is complex.`;
            
            setTimeout(function() {
                statusDiv.textContent = `Demo "conversion" to ${selectedFormat.toUpperCase()} complete. Download link provides original file. (Actual WAV conversion from trimmer is functional).`;
                if (preview.src) {
                    downloadLink.href = preview.src;
                    downloadLink.download = `${originalFileName}-converted-demo.${selectedFormat}`;
                    resultDiv.style.display = 'block';
                } else {
                    statusDiv.textContent = 'Error: No audio loaded for demo conversion.';
                }
            }, 1500);
        });
    }

    // 6. Audio Trimmer (Functional - WAV output)
    function initAudioTrimmer() {
        const uploadInput = document.getElementById('at-audio-upload');
        const previewAudio = document.getElementById('at-preview');
        const durationInfo = document.getElementById('at-duration-info');
        const controlsDiv = document.getElementById('at-trim-controls');
        const startTimeInput = document.getElementById('at-start-time');
        const endTimeInput = document.getElementById('at-end-time');
        const trimBtn = document.getElementById('at-trim-btn');
        const statusDiv = document.getElementById('at-status');
        const resultDiv = document.getElementById('at-result');
        const trimmedPreviewAudio = document.getElementById('at-trimmed-preview');
        const downloadLink = document.getElementById('at-download-link');
        let originalFileName = "audio";

        if (!audioContext) { // Initialize if not done globally or failed
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                statusDiv.textContent = "Web Audio API is not supported in this browser. Audio Trimmer cannot function.";
                trimBtn.disabled = true;
                uploadInput.disabled = true;
                return;
            }
        }

        uploadInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                originalFileName = file.name.split('.')[0];
                statusDiv.textContent = 'Loading audio file...';
                previewAudio.src = URL.createObjectURL(file);
                previewAudio.style.display = 'block';
                
                const reader = new FileReader();
                reader.onload = function(loadEvent) {
                    audioContext.decodeAudioData(loadEvent.target.result)
                        .then(buffer => {
                            originalAudioBuffer = buffer;
                            const duration = buffer.duration;
                            durationInfo.textContent = `Duration: ${duration.toFixed(2)}s`;
                            startTimeInput.value = 0;
                            endTimeInput.value = duration.toFixed(2);
                            startTimeInput.max = duration.toFixed(2);
                            endTimeInput.max = duration.toFixed(2);
                            controlsDiv.style.display = 'block';
                            resultDiv.style.display = 'none';
                            statusDiv.textContent = `Loaded: ${file.name}. Adjust trim times.`;
                        })
                        .catch(err => {
                            statusDiv.textContent = `Error decoding audio: ${err.message}`;
                            originalAudioBuffer = null;
                            controlsDiv.style.display = 'none';
                        });
                };
                reader.onerror = () => {
                    statusDiv.textContent = 'Error reading file.';
                }
                reader.readAsArrayBuffer(file);
            }
        });

        trimBtn.addEventListener('click', function() {
            if (!originalAudioBuffer) {
                statusDiv.textContent = 'Please upload and load an audio file first.';
                return;
            }

            const startTime = parseFloat(startTimeInput.value);
            const endTime = parseFloat(endTimeInput.value);

            if (isNaN(startTime) || isNaN(endTime) || startTime < 0 || endTime <= startTime || endTime > originalAudioBuffer.duration) {
                statusDiv.textContent = 'Invalid start or end time. Ensure End Time > Start Time and within audio duration.';
                return;
            }
            statusDiv.textContent = 'Trimming audio...';

            const startOffset = Math.floor(startTime * originalAudioBuffer.sampleRate);
            const endOffset = Math.floor(endTime * originalAudioBuffer.sampleRate);
            const frameCount = endOffset - startOffset;

            if (frameCount <= 0) {
                statusDiv.textContent = 'Trim duration is zero or negative.';
                return;
            }

            const newBuffer = audioContext.createBuffer(
                originalAudioBuffer.numberOfChannels,
                frameCount,
                originalAudioBuffer.sampleRate
            );

            for (let i = 0; i < originalAudioBuffer.numberOfChannels; i++) {
                const channelData = originalAudioBuffer.getChannelData(i);
                const newChannelData = newBuffer.getChannelData(i);
                newChannelData.set(channelData.subarray(startOffset, endOffset));
            }
            
            // Convert AudioBuffer to WAV Blob
            const wavBlob = audioBufferToWav(newBuffer);
            const wavUrl = URL.createObjectURL(wavBlob);

            trimmedPreviewAudio.src = wavUrl;
            trimmedPreviewAudio.style.display = 'block';
            downloadLink.href = wavUrl;
            downloadLink.download = `${originalFileName}-trimmed.wav`;
            resultDiv.style.display = 'block';
            statusDiv.textContent = 'Audio trimmed successfully! Preview and download as WAV.';
        });
    }
    
    // Helper: AudioBuffer to WAV (Simplified, 16-bit PCM)
    function audioBufferToWav(buffer) {
        let numOfChan = buffer.numberOfChannels,
            len = buffer.length * numOfChan * 2 + 44, // 2 bytes per sample
            abuffer = new ArrayBuffer(len),
            view = new DataView(abuffer),
            channels = [], i, sample,
            offset = 0,
            pos = 0;

        // WAV RIFF header
        setUint32(0x46464952); // "RIFF"
        setUint32(len - 8); // file length - 8
        setUint32(0x45564157); // "WAVE"

        // WAV ECNF header
        setUint32(0x20746d66); // "fmt " chunk
        setUint32(16); // length = 16
        setUint16(1); // PCM (uncompressed)
        setUint16(numOfChan);
        setUint32(buffer.sampleRate);
        setUint32(buffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
        setUint16(numOfChan * 2); // block-align
        setUint16(16); // 16-bit (hardcoded in this simple version)

        // WAV data chunk header
        setUint32(0x61746164); // "data" - chunk
        setUint32(len - pos); // chunk length

        // Write interleaved data
        for (i = 0; i < buffer.numberOfChannels; i++)
            channels.push(buffer.getChannelData(i));

        while (pos < len) {
            for (i = 0; i < numOfChan; i++) { // interleave channels
                sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
                sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF); // scale to 16-bit signed int
                view.setInt16(pos, sample, true); // write 16-bit sample
                pos += 2;
            }
            offset++;
             if (offset >= buffer.length) break; // Safety break if calculation is off
        }
        return new Blob([view], { type: 'audio/wav' });

        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
    }


    // 7. Age Calculator (Existing)
    function initAgeCalculator() {
        const birthDateInput = document.getElementById('ac-birth-date');
        const asOfDateInput = document.getElementById('ac-as-of-date');
        const calculateBtn = document.getElementById('ac-calculate-btn');
        const resultDiv = document.getElementById('ac-result');
        const resultText = document.getElementById('ac-age-result');

        asOfDateInput.valueAsDate = new Date(); 

        calculateBtn.addEventListener('click', function() {
            if (!birthDateInput.value) {
                resultText.textContent = 'Please enter your date of birth.';
                resultDiv.style.display = 'block';
                return;
            }
            const birthDate = new Date(birthDateInput.value);
            const asOfDate = asOfDateInput.value ? new Date(asOfDateInput.value) : new Date();
            
            if (isNaN(birthDate.getTime())) {
                resultText.textContent = 'Invalid date of birth entered.';
                resultDiv.style.display = 'block';
                return;
            }
             if (isNaN(asOfDate.getTime())) {
                resultText.textContent = 'Invalid "As of Date" entered.';
                resultDiv.style.display = 'block';
                return;
            }

            if (birthDate > asOfDate) {
                resultText.textContent = 'Birth date cannot be after the "As of Date".';
                resultDiv.style.display = 'block';
                return;
            }
            
            let years = asOfDate.getFullYear() - birthDate.getFullYear();
            let months = asOfDate.getMonth() - birthDate.getMonth();
            let days = asOfDate.getDate() - birthDate.getDate();
            
            if (days < 0) {
                months--;
                const lastDayOfPrevMonth = new Date(asOfDate.getFullYear(), asOfDate.getMonth(), 0).getDate();
                days += lastDayOfPrevMonth;
            }
            
            if (months < 0) {
                years--;
                months += 12;
            }
            
            resultText.textContent = `${years} years, ${months} months, and ${days} days old.`;
            resultDiv.style.display = 'block';
        });
    }

    // 8. EMI Calculator (Existing)
    function initEMICalculator() {
        const loanAmountInput = document.getElementById('emi-loan-amount');
        const interestRateInput = document.getElementById('emi-interest-rate');
        const loanTermInput = document.getElementById('emi-loan-term');
        const calculateBtn = document.getElementById('emi-calculate-btn');
        const resultDiv = document.getElementById('emi-result');
        const monthlyPaymentText = document.getElementById('emi-monthly-payment');
        const totalInterestText = document.getElementById('emi-total-interest');
        const totalPaymentText = document.getElementById('emi-total-payment');

        calculateBtn.addEventListener('click', function() {
            const principal = parseFloat(loanAmountInput.value);
            const annualRate = parseFloat(interestRateInput.value);
            const years = parseFloat(loanTermInput.value);
            
            if (isNaN(principal) || principal <= 0 || 
                isNaN(annualRate) || annualRate < 0 || 
                isNaN(years) || years <= 0) {
                monthlyPaymentText.textContent = 'Please enter valid positive numbers for all fields.';
                totalInterestText.textContent = '';
                totalPaymentText.textContent = '';
                resultDiv.style.display = 'block';
                return;
            }
            
            const monthlyRateDecimal = (annualRate / 100) / 12;
            const numberOfMonths = years * 12;
            let emi;
            
            if (monthlyRateDecimal === 0) { 
                 emi = principal / numberOfMonths;
            } else {
                 emi = (principal * monthlyRateDecimal * Math.pow(1 + monthlyRateDecimal, numberOfMonths)) / 
                       (Math.pow(1 + monthlyRateDecimal, numberOfMonths) - 1);
            }
            
            if (!isFinite(emi)) { // Handle potential NaN/Infinity from formula with extreme values
                monthlyPaymentText.textContent = 'Could not calculate EMI with the provided values. Please check inputs.';
                totalInterestText.textContent = '';
                totalPaymentText.textContent = '';
                resultDiv.style.display = 'block';
                return;
            }
            
            const totalPayment = emi * numberOfMonths;
            const totalInterest = totalPayment - principal;
            
            monthlyPaymentText.textContent = `Monthly Payment (EMI): $${emi.toFixed(2)}`;
            totalInterestText.textContent = `Total Interest Paid: $${totalInterest.toFixed(2)}`;
            totalPaymentText.textContent = `Total Amount Paid: $${totalPayment.toFixed(2)}`;
            
            resultDiv.style.display = 'block';
        });
    }

    // 9. SIP Calculator (Existing)
    function initSIPCalculator() {
        const monthlyAmountInput = document.getElementById('sip-monthly-amount');
        const expectedReturnInput = document.getElementById('sip-expected-return');
        const investmentPeriodInput = document.getElementById('sip-investment-period');
        const calculateBtn = document.getElementById('sip-calculate-btn');
        const resultDiv = document.getElementById('sip-result');
        const investedAmountText = document.getElementById('sip-invested-amount');
        const estimatedReturnsText = document.getElementById('sip-estimated-returns');
        const totalValueText = document.getElementById('sip-total-value');

        calculateBtn.addEventListener('click', function() {
            const monthlyInvestment = parseFloat(monthlyAmountInput.value);
            const annualReturnRate = parseFloat(expectedReturnInput.value);
            const years = parseFloat(investmentPeriodInput.value);
            
            if (isNaN(monthlyInvestment) || monthlyInvestment <= 0 ||
                isNaN(annualReturnRate) || annualReturnRate < 0 || // Allow 0% return
                isNaN(years) || years <= 0) {
                investedAmountText.textContent = 'Please enter valid positive numbers for all fields.';
                estimatedReturnsText.textContent = '';
                totalValueText.textContent = '';
                resultDiv.style.display = 'block';
                return;
            }
            
            const numberOfMonths = years * 12;
            const monthlyReturnRateDecimal = (annualReturnRate / 100) / 12;
            
            let futureValue;
            if (monthlyReturnRateDecimal === 0) { 
                futureValue = monthlyInvestment * numberOfMonths;
            } else {
                futureValue = monthlyInvestment * 
                               ( (Math.pow(1 + monthlyReturnRateDecimal, numberOfMonths) - 1) / monthlyReturnRateDecimal ) * 
                               (1 + monthlyReturnRateDecimal);
            }
             if (!isFinite(futureValue)) {
                investedAmountText.textContent = 'Could not calculate SIP with the provided values. Please check inputs.';
                estimatedReturnsText.textContent = '';
                totalValueText.textContent = '';
                resultDiv.style.display = 'block';
                return;
            }
            
            const totalInvested = monthlyInvestment * numberOfMonths;
            const wealthGained = futureValue - totalInvested;
            
            investedAmountText.textContent = `Total Invested Amount: $${totalInvested.toFixed(2)}`;
            estimatedReturnsText.textContent = `Estimated Returns (Wealth Gained): $${wealthGained.toFixed(2)}`;
            totalValueText.textContent = `Total Future Value: $${futureValue.toFixed(2)}`;
            
            resultDiv.style.display = 'block';
        });
    }

    // 10. QR Code Generator (Functional - using qrcodegen.js logic)
    // --- qrcodegen.js (TypeScript) - V1.8.0 - Copyright (c) 2022 Nayuki ---
    // --- Adapted and simplified for this specific use case as pure JS ---
    // --- Full library has more features and robustness, this is a core subset ---
    var qrcodegen; (function(qrcodegen) {
        class QrCode {
            static encodeText(text, ecl) {
                const segs = qrcodegen.QrSegment.makeSegments(text);
                return QrCode.encodeSegments(segs, ecl);
            }
            static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
                if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) || mask < -1 || mask > 7)
                    throw new RangeError("Invalid argument");
                let version;
                let dataUsedBits;
                for (version = minVersion;; version++) {
                    const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
                    const usedBits = qrcodegen.QrSegment.getTotalBits(segs, version);
                    if (usedBits <= dataCapacityBits) {
                        dataUsedBits = usedBits;
                        break;
                    }
                    if (version >= maxVersion)
                        throw new RangeError("Data too long");
                }
                const eccReedSolomon = new ReedSolomonGenerator(QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][version]);
                const dataCodewords = qrcodegen.QrSegment.appendBitsToBytes(segs, version, dataUsedBits);
                const allCodewords = QrCode.addEccAndInterleave(dataCodewords, version, ecl, eccReedSolomon);
                const qr = new QrCode(version, ecl, allCodewords, mask);
                return qr;
            }
            constructor(version, ecl, dataCodewords, msk) {
                this.version = version;
                this.errorCorrectionLevel = ecl;
                this.size = version * 4 + 17;
                this.modules = [];
                for (let i = 0; i < this.size; i++)
                    this.modules[i] = [];
                this.drawFunctionPatterns();
                const allCodewords = this.addEccAndInterleave(dataCodewords);
                this.drawCodewords(allCodewords);
                if (msk == -1) {
                    let minPenalty = Infinity;
                    for (let i = 0; i < 8; i++) {
                        this.applyMask(i);
                        this.drawFormatBits(i);
                        const penalty = this.getPenaltyScore();
                        if (penalty < minPenalty) {
                            msk = i;
                            minPenalty = penalty;
                        }
                        this.applyMask(i);
                    }
                }
                this.mask = msk;
                this.applyMask(msk);
                this.drawFormatBits(msk);
                this.isFunction = [];
                for (let i = 0; i < this.size; i++)
                    this.isFunction[i] = [];
                this.drawFunctionPatterns();
            }
            getModule(x, y) { return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x]; }
            drawFunctionPatterns() {
                for (let i = 0; i < this.size; i++) {
                    this.setFunctionModule(6, i, i % 2 == 0);
                    this.setFunctionModule(i, 6, i % 2 == 0);
                }
                this.drawFinderPattern(3, 3);
                this.drawFinderPattern(this.size - 4, 3);
                this.drawFinderPattern(3, this.size - 4);
                const alignPatPos = QrCode.getAlignmentPatternPositions(this.version);
                const numAlign = alignPatPos.length;
                for (let i = 0; i < numAlign; i++) {
                    for (let j = 0; j < numAlign; j++) {
                        if (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))
                            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
                    }
                }
                this.drawFormatBits(0);
                if (this.version >= 7)
                    this.drawVersion();
            }
            drawFormatBits(mask) {
                const data = this.errorCorrectionLevel.formatBits << 3 | mask;
                let rem = data;
                for (let i = 0; i < 10; i++)
                    rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
                const bits = (data << 10 | rem) ^ 0x5412;
                for (let i = 0; i < 15; i++) {
                    const y = QrCode.VERSION_INFO_COORDINATES[i][0];
                    const x = QrCode.VERSION_INFO_COORDINATES[i][1];
                    const dark = ((bits >>> i) & 1) != 0;
                    this.modules[y][x] = dark;
                    if (x < 8) this.modules[x][8] = dark; else this.modules[this.size - 1 - (14-x)][8] = dark;
                    if (y < 8) this.modules[8][y] = dark; else this.modules[8][this.size - 1 - (14-y)] = dark;
                }
            }
            drawVersion() {
                if (this.version < 7) return;
                let rem = this.version;
                for (let i = 0; i < 12; i++)
                    rem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);
                const bits = this.version << 12 | rem;
                for (let i = 0; i < 18; i++) {
                    const y = Math.floor(i / 3);
                    const x = this.size - 11 + i % 3;
                    const dark = ((bits >>> i) & 1) != 0;
                    this.setFunctionModule(x,y,dark);
                    this.setFunctionModule(y,x,dark);
                }
            }
            drawFinderPattern(x, y) {
                for (let dy = -4; dy <= 4; dy++) {
                    for (let dx = -4; dx <= 4; dx++) {
                        const dist = Math.max(Math.abs(dx), Math.abs(dy));
                        const xx = x + dx;
                        const yy = y + dy;
                        if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
                            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
                    }
                }
            }
            drawAlignmentPattern(x, y) {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++)
                        this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
                }
            }
            setFunctionModule(x, y, isDark) {
                this.modules[y][x] = isDark;
                if (this.isFunction) this.isFunction[y][x] = true;
            }
            addEccAndInterleave(data) {
                const ver = this.version;
                const ecl = this.errorCorrectionLevel;
                if (data.length != QrCode.getNumDataCodewords(ver, ecl))
                    throw new RangeError("Invalid argument");
                const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
                const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
                const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
                const numShortBlocks = numBlocks - rawCodewords % numBlocks;
                const shortBlockLen = Math.floor(rawCodewords / numBlocks);
                const rs = new ReedSolomonGenerator(blockEccLen);
                let blocks = [];
                let k = 0;
                for (let i = 0; i < numBlocks; i++) {
                    let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
                    k += dat.length;
                    const ecc = rs.getRemainder(dat);
                    if (i < numShortBlocks) dat.push(0);
                    blocks.push(dat.concat(ecc));
                }
                let result = [];
                for (let i = 0; i < blocks[0].length; i++) {
                    for (let j = 0; j < blocks.length; j++) {
                        if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
                            result.push(blocks[j][i]);
                    }
                }
                return result;
            }
            drawCodewords(data) {
                if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8))
                    throw new RangeError("Invalid argument");
                let i = 0;
                for (let right = this.size - 1; right >= 1; right -= 2) {
                    if (right == 6) right = 5;
                    for (let vert = 0; vert < this.size; vert++) {
                        for (let j = 0; j < 2; j++) {
                            const x = right - j;
                            const upward = ((right + 1) & 2) == 0;
                            const y = upward ? this.size - 1 - vert : vert;
                            if (!this.isFunction[y][x] && i < data.length * 8) {
                                this.modules[y][x] = ((data[i >>> 3] >>> (7 - (i & 7))) & 1) != 0;
                                i++;
                            }
                        }
                    }
                }
            }
            applyMask(mask) {
                if (mask < 0 || mask > 7) throw new RangeError("Mask out of range");
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        let invert;
                        switch (mask) {
                            case 0: invert = (x + y) % 2 == 0; break;
                            case 1: invert = y % 2 == 0; break;
                            case 2: invert = x % 3 == 0; break;
                            case 3: invert = (x + y) % 3 == 0; break;
                            case 4: invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0; break;
                            case 5: invert = (x * y) % 2 + (x * y) % 3 == 0; break;
                            case 6: invert = ((x * y) % 2 + (x * y) % 3) % 2 == 0; break;
                            case 7: invert = ((x + y) % 2 + (x * y) % 3) % 2 == 0; break;
                            default: throw new Error("Unreachable");
                        }
                        if (!this.isFunction[y][x] && invert)
                            this.modules[y][x] = !this.modules[y][x];
                    }
                }
            }
            getPenaltyScore() {
                let result = 0;
                for (let y = 0; y < this.size; y++) {
                    let runColor = false;
                    let runX = 0;
                    let runHistory = [0, 0, 0, 0, 0, 0, 0];
                    for (let x = 0; x < this.size; x++) {
                        if (this.modules[y][x] == runColor) {
                            runX++;
                            if (runX == 5) result += QrCode.PENALTY_N1;
                            else if (runX > 5) result++;
                        } else {
                            this.finderPenaltyAddHistory(runX, runHistory);
                            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
                            runColor = this.modules[y][x];
                            runX = 1;
                        }
                    }
                    result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;
                }
                for (let x = 0; x < this.size; x++) {
                    let runColor = false;
                    let runY = 0;
                    let runHistory = [0, 0, 0, 0, 0, 0, 0];
                    for (let y = 0; y < this.size; y++) {
                        if (this.modules[y][x] == runColor) {
                            runY++;
                            if (runY == 5) result += QrCode.PENALTY_N1;
                            else if (runY > 5) result++;
                        } else {
                            this.finderPenaltyAddHistory(runY, runHistory);
                            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
                            runColor = this.modules[y][x];
                            runY = 1;
                        }
                    }
                    result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode.PENALTY_N3;
                }
                let black = 0;
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const color = this.modules[y][x];
                        if (x > 0 && y > 0 && color == this.modules[y][x - 1] && color == this.modules[y - 1][x] && color == this.modules[y - 1][x - 1])
                            result += QrCode.PENALTY_N2;
                        if (color) black++;
                    }
                }
                const total = this.size * this.size;
                const k = Math.floor((Math.abs(black * 20 - total * 10) + total - 1) / total) -1; // Math.ceil simplified
                result += k * QrCode.PENALTY_N4;
                return result;
            }
            finderPenaltyCountPatterns(runHistory) {
                const n = runHistory[1];
                if (n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n) {
                    if (this.finderPenaltyCheckRatio(runHistory, 0) || this.finderPenaltyCheckRatio(runHistory, 6))
                        return 1;
                }
                return 0;
            }
            finderPenaltyCheckRatio(runHistory, k) {
                let val = 0;
                for (let i=0; i<7; i++) val = val*2 + runHistory[i];
                return val == 0b0000101110100; // Needs to be adapted for JS from original C++
            }
            finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
                if (currentRunColor) {
                    this.finderPenaltyAddHistory(currentRunLength, runHistory);
                    currentRunLength = 0;
                }
                currentRunLength += this.size;
                this.finderPenaltyAddHistory(currentRunLength, runHistory);
                return this.finderPenaltyCountPatterns(runHistory);
            }
            finderPenaltyAddHistory(currentRunLength, runHistory) {
                if (runHistory[0] == 0) currentRunLength += this.size;
                runHistory.pop();
                runHistory.unshift(currentRunLength);
            }
            static getNumRawDataModules(ver) {
                let result = (16 * ver + 128) * ver + 64;
                if (ver >= 2) {
                    const numAlign = Math.floor(ver / 7) + 2;
                    result -= (25 * numAlign - 10) * numAlign - 55;
                    if (ver >= 7) result -= 36;
                }
                return result;
            }
            static getNumDataCodewords(ver, ecl) {
                return Math.floor(QrCode.getNumRawDataModules(ver) / 8) -
                    QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *
                        QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
            }
            static getAlignmentPatternPositions(ver) {
                if (ver == 1) return [];
                else {
                    const numAlign = Math.floor(ver / 7) + 2;
                    const step = (ver == 32) ? 26 : Math.ceil((ver * 4 + 4) / (numAlign * 2 - 2) / 2) * 2;
                    let result = [6];
                    for (let pos = ver * 4 + 10; result.length < numAlign; pos -= step)
                        result.splice(1, 0, pos);
                    return result;
                }
            }
        }
        QrCode.MIN_VERSION = 1; QrCode.MAX_VERSION = 40;
        QrCode.PENALTY_N1 = 3; QrCode.PENALTY_N2 = 3; QrCode.PENALTY_N3 = 40; QrCode.PENALTY_N4 = 10;
        QrCode.ECC_CODEWORDS_PER_BLOCK = [
            [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
            [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
            [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        ];
        QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
            [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
            [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
            [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 20, 23, 23, 25, 27, 29, 32, 34, 36, 38, 41, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
            [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77],
        ];
         QrCode.VERSION_INFO_COORDINATES = [ // Simplified for space, real one is a lookup table
            [8,0],[8,1],[8,2],[8,3],[8,4],[8,5],[8,7], // Top-left to bottom-left format info
            [7,8],[5,8],[4,8],[3,8],[2,8],[1,8],[0,8]  // Top-right to top-left format info
        ];

        qrcodegen.QrCode = QrCode;
        class QrSegment {
            static makeBytes(data) { return [new QrSegment(QrSegment.Mode.BYTE, data.length, data)]; }
            static makeNumeric(digits) {
                if (!/^[0-9]*$/.test(digits)) throw new RangeError("String contains non-numeric characters");
                let bb = [];
                for (let i = 0; i < digits.length;) {
                    const n = Math.min(digits.length - i, 3);
                    QrSegment.appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
                    i += n;
                }
                return [new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb)];
            }
            static makeAlphanumeric(text) {
                if (!/^[A-Z0-9 $%*+.\/:+-]*$/.test(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
                let bb = [];
                let i;
                for (i = 0; i + 2 <= text.length; i += 2) {
                    let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
                    temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
                    QrSegment.appendBits(temp, 11, bb);
                }
                if (i < text.length)
                    QrSegment.appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
                return [new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb)];
            }
            static makeSegments(text) {
                if (text == "") return [];
                else if (/^[0-9]*$/.test(text)) return QrSegment.makeNumeric(text);
                else if (/^[A-Z0-9 $%*+.\/:+-]*$/.test(text)) return QrSegment.makeAlphanumeric(text);
                else {
                    let bytes = [];
                    for (let i = 0; i < text.length; i++) { // UTF-8 encoding
                        let c = text.charCodeAt(i);
                        if (c < 0x80) bytes.push(c);
                        else if (c < 0x800) { bytes.push(0xC0 | (c >> 6)); bytes.push(0x80 | (c & 0x3F)); }
                        else if (c < 0xD800 || c >= 0xE000) { bytes.push(0xE0 | (c >> 12)); bytes.push(0x80 | ((c >> 6) & 0x3F)); bytes.push(0x80 | (c & 0x3F)); }
                        else { // UTF-16 surrogate pairs
                            c = 0x10000 + (((c & 0x03FF) << 10) | (text.charCodeAt(++i) & 0x03FF));
                            bytes.push(0xF0 | (c >> 18)); bytes.push(0x80 | ((c >> 12) & 0x3F)); bytes.push(0x80 | ((c >> 6) & 0x3F)); bytes.push(0x80 | (c & 0x3F));
                        }
                    }
                    return QrSegment.makeBytes(bytes);
                }
            }
            constructor(mode, numChars, bitData) {
                this.mode = mode;
                this.numChars = numChars;
                this.bitData = bitData;
            }
            getBits() { return this.bitData.slice(); }
            static getTotalBits(segs, version) {
                let result = 0;
                for (const seg of segs) {
                    const ccbits = seg.mode.numCharCountBits(version);
                    result += 4 + ccbits + seg.bitData.length;
                }
                return result;
            }
            static appendBitsToBytes(segs, version, dataUsedBits) {
                let result = [];
                let bitBuffer = 0;
                let bitBufferLen = 0;
                for (const seg of segs) {
                    QrSegment.appendBits(seg.mode.modeBits, 4, result);
                    QrSegment.appendBits(seg.numChars, seg.mode.numCharCountBits(version), result);
                    for (const b of seg.bitData)
                        result.push(b); // This assumes bitData is already byte-aligned or handled by appendBits
                }
                // This part needs to handle bit packing into bytes if bitData is not byte aligned.
                // For simplicity, we will assume QrSegment.appendBits correctly manages a bit buffer and flushes bytes.
                // The provided code seems to structure appendBits to handle bits directly.
                // The original library correctly handles this bit-to-byte packing.
                // This simplified adaptation might need refinement here.

                // Let's try to use a common bit buffer logic for appendBits
                let packedBytes = [];
                let currentByte = 0;
                let bitsInCurrentByte = 0;

                function flushByte() {
                    if (bitsInCurrentByte > 0) {
                        packedBytes.push(currentByte);
                        currentByte = 0;
                        bitsInCurrentByte = 0;
                    }
                }
                
                function addBitToPackedBytes(bit) {
                    currentByte = (currentByte << 1) | (bit ? 1:0);
                    bitsInCurrentByte++;
                    if (bitsInCurrentByte === 8) flushByte();
                }

                // Simplified appendBits logic directly populating packedBytes
                const tempBitArray = [];
                for (const seg of segs) {
                    for(let i=3; i>=0; i--) tempBitArray.push((seg.mode.modeBits >>> i) & 1);
                    const ccbits = seg.mode.numCharCountBits(version);
                    for(let i=ccbits-1; i>=0; i--) tempBitArray.push((seg.numChars >>> i) & 1);
                    for (const bit of seg.bitData) tempBitArray.push(bit); // Assuming seg.bitData is an array of bits
                }
                
                // Terminator
                const dataCapacityBits = QrCode.getNumDataCodewords(version, qrcodegen.Ecc.LOW) * 8; // Use a default ECL for capacity
                const terminatorBits = Math.min(4, dataCapacityBits - tempBitArray.length);
                for(let i=0; i<terminatorBits; i++) tempBitArray.push(0);

                // Pad to multiple of 8
                while (tempBitArray.length % 8 !== 0) tempBitArray.push(0);

                // Add pad bytes if needed
                const PADDING_BYTE_1 = 0xEC;
                const PADDING_BYTE_2 = 0x11;
                for (let padtoggle = false; tempBitArray.length < dataCapacityBits; padtoggle = !padtoggle) {
                    const padByte = padtoggle ? PADDING_BYTE_2 : PADDING_BYTE_1;
                    for(let i=7; i>=0; i--) tempBitArray.push((padByte >>> i) & 1);
                }


                for (const bit of tempBitArray) addBitToPackedBytes(bit);
                flushByte(); // Flush any remaining bits

                return packedBytes;

            }
            // Original appendBits was to a bit array, then packed.
            // For this simplified context, let's assume bitData in QrSegment is already an array of bits {0,1}.
            static appendBits(val, len, bb) { for (let i = len - 1; i >= 0; i--) bb.push((val >>> i) & 1); }
        }
        QrSegment.Mode = class Mode {
            constructor(modeBits, numBitsCharCount) {
                this.modeBits = modeBits;
                this.numBitsCharCount = numBitsCharCount;
            }
            numCharCountBits(ver) { return this.numBitsCharCount[Math.floor((ver + 7) / 17)]; }
        };
        QrSegment.Mode.NUMERIC = new QrSegment.Mode(0x1, [10, 12, 14]);
        QrSegment.Mode.ALPHANUMERIC = new QrSegment.Mode(0x2, [9, 11, 13]);
        QrSegment.Mode.BYTE = new QrSegment.Mode(0x4, [8, 16, 16]);
        QrSegment.Mode.KANJI = new QrSegment.Mode(0x8, [8, 10, 12]);
        QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+./:+-";
        qrcodegen.QrSegment = QrSegment;
        class Ecc {
            constructor(ordinal, formatBits) {
                this.ordinal = ordinal;
                this.formatBits = formatBits;
            }
        }
        Ecc.LOW = new Ecc(0, 1);
        Ecc.MEDIUM = new Ecc(1, 0);
        Ecc.QUARTILE = new Ecc(2, 3);
        Ecc.HIGH = new Ecc(3, 2);
        qrcodegen.Ecc = Ecc;
        class ReedSolomonGenerator {
            constructor(degree) {
                if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
                this.coefficients = [];
                for (let i = 0; i < degree - 1; i++) this.coefficients.push(0);
                this.coefficients.push(1);
                let root = 1;
                for (let i = 0; i < degree; i++) {
                    for (let j = 0; j < this.coefficients.length; j++) {
                        this.coefficients[j] = ReedSolomonGenerator.multiply(this.coefficients[j], root);
                        if (j + 1 < this.coefficients.length) this.coefficients[j] ^= this.coefficients[j + 1];
                    }
                    root = ReedSolomonGenerator.multiply(root, 0x02);
                }
            }
            getRemainder(data) {
                let result = this.coefficients.map(_ => 0);
                for (const b of data) {
                    const factor = b ^ result.shift();
                    result.push(0);
                    for (let i = 0; i < result.length; i++)
                        result[i] ^= ReedSolomonGenerator.multiply(this.coefficients[i], factor);
                }
                return result;
            }
            static multiply(x, y) {
                if (x == 0 || y == 0) return 0;
                let z = 0;
                for (let i = 7; i >= 0; i--) {
                    z = (z << 1) ^ ((z >>> 7) * 0x11D);
                    if (((y >>> i) & 1) != 0) z ^= x;
                }
                return z;
            }
        }
    })(qrcodegen || (qrcodegen = {}));
    // End of qrcodegen adaptation

    function initQRGenerator() {
        const contentInput = document.getElementById('qr-content');
        const sizeSlider = document.getElementById('qr-size');
        const sizeValueSpan = document.getElementById('qr-size-value');
        const eclSelect = document.getElementById('qr-error-correction');
        const generateBtn = document.getElementById('qr-generate-btn');
        const resultDiv = document.getElementById('qr-result');
        const canvas = document.getElementById('qr-canvas');
        const downloadLink = document.getElementById('qr-download-link');
        const statusEl = document.getElementById('qr-status');

        sizeSlider.addEventListener('input', () => sizeValueSpan.textContent = sizeSlider.value);

        generateBtn.addEventListener('click', function() {
            const text = contentInput.value.trim();
            const size = parseInt(sizeSlider.value);
            let ecl;
            switch(eclSelect.value) {
                case 'L': ecl = qrcodegen.Ecc.LOW; break;
                case 'M': ecl = qrcodegen.Ecc.MEDIUM; break;
                case 'Q': ecl = qrcodegen.Ecc.QUARTILE; break;
                case 'H': ecl = qrcodegen.Ecc.HIGH; break;
                default: ecl = qrcodegen.Ecc.MEDIUM;
            }
            
            if (!text) {
                showStatus('qr', 'Please enter some text or URL for the QR code.', true);
                resultDiv.style.display = 'none';
                return;
            }
            statusEl.textContent = 'Generating QR Code...';

            try {
                const qr = qrcodegen.QrCode.encodeText(text, ecl);
                const ctx = canvas.getContext("2d");
                const scale = size / qr.size;
                canvas.width = canvas.height = size;
                ctx.clearRect(0, 0, size, size);
                ctx.fillStyle = "black";
                for (let y = 0; y < qr.size; y++) {
                    for (let x = 0; x < qr.size; x++) {
                        if (qr.getModule(x, y))
                            ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.download = 'qrcode.png';
                resultDiv.style.display = 'block';
                statusEl.textContent = 'QR Code generated successfully!';
            } catch (e) {
                console.error("QR Code generation error:", e);
                showStatus('qr', `Error generating QR code: ${e.message}. Data might be too long for selected settings or an internal error occurred.`, true);
                resultDiv.style.display = 'none';
            }
        });
    }


    // 11. Password Generator (Existing - enhanced strength calc)
    function initPasswordGenerator() {
        const lengthSlider = document.getElementById('pg-length');
        const lengthValue = document.getElementById('pg-length-value');
        const uppercaseCheck = document.getElementById('pg-uppercase');
        const lowercaseCheck = document.getElementById('pg-lowercase');
        const numbersCheck = document.getElementById('pg-numbers');
        const symbolsCheck = document.getElementById('pg-symbols');
        const generateBtn = document.getElementById('pg-generate-btn');
        const resultDiv = document.getElementById('pg-result');
        const passwordInput = document.getElementById('pg-password');
        const copyBtn = document.getElementById('pg-copy-btn');
        const strengthProgress = document.getElementById('pg-strength-progress');
        const strengthText = document.getElementById('pg-strength-text');

        lengthSlider.addEventListener('input', function() { lengthValue.textContent = this.value; });

        generateBtn.addEventListener('click', function() {
            const length = parseInt(lengthSlider.value);
            const opts = {
                uppercase: uppercaseCheck.checked,
                lowercase: lowercaseCheck.checked,
                numbers: numbersCheck.checked,
                symbols: symbolsCheck.checked
            };
            
            const charSets = {
                uppercase: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                lowercase: 'abcdefghijklmnopqrstuvwxyz',
                numbers: '0123456789',
                symbols: '!@#$%^&*()_+-=[]{}|;:,.<>?'
            };

            let availableChars = "";
            let guaranteedChars = "";
            let typesCount = 0;

            for (const type in opts) {
                if (opts[type]) {
                    availableChars += charSets[type];
                    guaranteedChars += charSets[type][Math.floor(Math.random() * charSets[type].length)];
                    typesCount++;
                }
            }
            
            if (!availableChars) {
                alert('Please select at least one character type.');
                resultDiv.style.display = 'none';
                return;
            }
            if (length < typesCount) {
                 alert(`Password length (${length}) is too short to include one of each selected character type (${typesCount}). Please increase length or reduce character types.`);
                 resultDiv.style.display = 'none';
                 return;
            }


            let password = guaranteedChars;
            for (let i = guaranteedChars.length; i < length; i++) {
                password += availableChars[Math.floor(Math.random() * availableChars.length)];
            }
            
            password = password.split('').sort(() => 0.5 - Math.random()).join(''); // Shuffle
            passwordInput.value = password;
            
            // Password strength (more nuanced)
            let strengthScore = 0;
            strengthScore += length * 4; // Length bonus
            if (opts.uppercase) strengthScore += (length - (password.match(/[A-Z]/g) || []).length) * -2 + 10; // Bonus for presence, penalty if not enough
            if (opts.lowercase) strengthScore += (length - (password.match(/[a-z]/g) || []).length) * -2 + 10;
            if (opts.numbers) strengthScore += (password.match(/\d/g) || []).length * 4;
            if (opts.symbols) strengthScore += (password.match(/[\!@#\$%\^&\*\(\)\_\+\-\=\{\}\[\]\|;:\,\.\<\>\?]/g) || []).length * 6;
            
            // Penalties
            if (password.match(/^[a-z]+$/) || password.match(/^[A-Z]+$/) || password.match(/^\d+$/) ) strengthScore -= 20; // Only one type
            
            let consecutiveUpper = 0, consecutiveLower = 0, consecutiveNumber = 0;
            for(let i=0; i < password.length -1; i++){
                if(charSets.uppercase.includes(password[i]) && charSets.uppercase.includes(password[i+1])) consecutiveUpper++;
                if(charSets.lowercase.includes(password[i]) && charSets.lowercase.includes(password[i+1])) consecutiveLower++;
                if(charSets.numbers.includes(password[i]) && charSets.numbers.includes(password[i+1])) consecutiveNumber++;
            }
            strengthScore -= consecutiveUpper * 2;
            strengthScore -= consecutiveLower * 2;
            strengthScore -= consecutiveNumber * 2;


            strengthScore = Math.max(0, Math.min(100, strengthScore)); // Normalize to 0-100

            let strengthLabel, strengthColor;
            if (strengthScore >= 80) { strengthLabel = 'Very Strong'; strengthColor = 'green'; }
            else if (strengthScore >= 60) { strengthLabel = 'Strong'; strengthColor = 'limegreen'; }
            else if (strengthScore >= 40) { strengthLabel = 'Good'; strengthColor = 'orange'; }
            else if (strengthScore >= 20) { strengthLabel = 'Weak'; strengthColor = '#FF6347'; } // Tomato
            else { strengthLabel = 'Very Weak'; strengthColor = 'red'; }
            
            strengthProgress.style.width = strengthScore + '%';
            strengthProgress.style.backgroundColor = strengthColor;
            strengthText.textContent = strengthLabel;
            
            resultDiv.style.display = 'block';
        });

        copyBtn.addEventListener('click', function() {
            if (passwordInput.value) {
                navigator.clipboard.writeText(passwordInput.value)
                    .then(() => alert('Password copied to clipboard!'))
                    .catch(err => { alert('Failed to copy.'); });
            }
        });
    }

    // 12. Word Counter (Existing - added sentence/paragraph)
    function initWordCounter() {
        const textInput = document.getElementById('wc-text');
        const counts = {
            words: document.getElementById('wc-word-count'),
            chars: document.getElementById('wc-char-count'),
            charsNoSpace: document.getElementById('wc-char-no-spaces'),
            spaces: document.getElementById('wc-space-count'),
            sentences: document.getElementById('wc-sentence-count'),
            paragraphs: document.getElementById('wc-paragraph-count'),
            readingTime: document.getElementById('wc-reading-time')
        };

        textInput.addEventListener('input', function() {
            const text = this.value;
            
            counts.words.textContent = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
            counts.chars.textContent = text.length;
            counts.charsNoSpace.textContent = text.replace(/\s/g, '').length;
            counts.spaces.textContent = (text.match(/\s/g) || []).length;

            // Sentence count (basic: split by . ! ?)
            counts.sentences.textContent = text.trim() === '' ? 0 : (text.match(/[.!?]+/g) || []).length || (text.trim() ? 1 : 0) ;
            // Paragraph count (basic: split by double newlines or more)
            counts.paragraphs.textContent = text.trim() === '' ? 0 : text.split(/\n\s*\n/).filter(p => p.trim() !== "").length || (text.trim() ? 1 : 0);
            
            const wpm = 200; 
            const wordCount = parseInt(counts.words.textContent);
            const minutes = wordCount / wpm;
            if (wordCount === 0) counts.readingTime.textContent = `0 seconds`;
            else if (minutes < 1) counts.readingTime.textContent = `~${Math.ceil(minutes * 60)} seconds`;
            else counts.readingTime.textContent = `~${Math.ceil(minutes)} minute${Math.ceil(minutes) > 1 ? 's' : ''}`;
        });
    }

    // 13. Base64 Converter (Existing)
    function initBase64Converter() {
        const directionSelect = document.getElementById('b64-direction');
        const inputTextarea = document.getElementById('b64-input');
        const convertBtn = document.getElementById('b64-convert-btn');
        const resultDiv = document.getElementById('b64-result');
        const outputTextarea = document.getElementById('b64-output');
        const copyBtn = document.getElementById('b64-copy-btn');
        const statusEl = document.getElementById('b64-status');

        convertBtn.addEventListener('click', function() {
            const text = inputTextarea.value; 
            const direction = directionSelect.value;
            statusEl.textContent = '';
            
            if (!text && direction === 'encode') { // Allow empty for decode if user wants to try
                showStatus('b64', 'Please enter some text to encode.', true);
                resultDiv.style.display = 'none';
                return;
            }
            
            try {
                if (direction === 'encode') {
                    outputTextarea.value = btoa(unescape(encodeURIComponent(text)));
                } else {
                    outputTextarea.value = decodeURIComponent(escape(atob(text)));
                }
                resultDiv.style.display = 'block';
            } catch (e) {
                let errorMsg = 'Error during conversion: ' + e.message;
                if (direction === 'decode' && e.name === 'InvalidCharacterError') {
                    errorMsg += '. Ensure input is valid Base64. It might contain non-Base64 characters or be improperly padded.';
                }
                showStatus('b64', errorMsg, true);
                resultDiv.style.display = 'none';
            }
        });

        copyBtn.addEventListener('click', function() {
            if (outputTextarea.value) {
                navigator.clipboard.writeText(outputTextarea.value)
                    .then(() => { statusEl.textContent = 'Result copied to clipboard!'; })
                    .catch(err => { showStatus('b64', 'Failed to copy.', true); });
            }
        });
    }

    // 14. Color Picker (Existing - input fields for values)
    function copyToClipboardCP(elementId, isInput = false) {
        const el = document.getElementById(elementId);
        const text = isInput ? el.value : el.textContent;
        navigator.clipboard.writeText(text).then(() => {
            alert('Copied: ' + text);
        }).catch(err => { alert('Failed to copy.'); });
    }

    function initColorPicker() {
        const colorInput = document.getElementById('cp-color-input');
        const previewBox = document.getElementById('cp-preview');
        const hexValueInput = document.getElementById('cp-hex-value-input');
        const rgbValueInput = document.getElementById('cp-rgb-value-input');
        const hslValueInput = document.getElementById('cp-hsl-value-input');

        function updateColorValues(hexColor) {
            previewBox.style.backgroundColor = hexColor;
            hexValueInput.value = hexColor.toUpperCase();

            let r = 0, g = 0, b = 0;
            if (hexColor.length === 7) { 
                r = parseInt(hexColor.substring(1, 3), 16);
                g = parseInt(hexColor.substring(3, 5), 16);
                b = parseInt(hexColor.substring(5, 7), 16);
            } else if (hexColor.length === 4) { 
                r = parseInt(hexColor[1] + hexColor[1], 16);
                g = parseInt(hexColor[2] + hexColor[2], 16);
                b = parseInt(hexColor[3] + hexColor[3], 16);
            }
            rgbValueInput.value = `rgb(${r}, ${g}, ${b})`;

            const r_norm = r / 255, g_norm = g / 255, b_norm = b / 255;
            const max = Math.max(r_norm, g_norm, b_norm), min = Math.min(r_norm, g_norm, b_norm);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } 
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r_norm: h = (g_norm - b_norm) / d + (g_norm < b_norm ? 6 : 0); break;
                    case g_norm: h = (b_norm - r_norm) / d + 2; break;
                    case b_norm: h = (r_norm - g_norm) / d + 4; break;
                }
                h /= 6;
            }
            hslValueInput.value = `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
        }
        colorInput.addEventListener('input', function() { updateColorValues(this.value); });
        updateColorValues(colorInput.value); // Initial call
    }

    // 15. Text to Speech (Existing - enhanced UI updates)
    function initTextToSpeech() {
        const textInput = document.getElementById('tts-text');
        const voiceSelect = document.getElementById('tts-voice');
        const rateSlider = document.getElementById('tts-rate');
        const rateValueSpan = document.getElementById('tts-rate-value');
        const pitchSlider = document.getElementById('tts-pitch');
        const pitchValueSpan = document.getElementById('tts-pitch-value');
        const speakBtn = document.getElementById('tts-speak-btn');
        const pauseBtn = document.getElementById('tts-pause-btn');
        const resumeBtn = document.getElementById('tts-resume-btn');
        const stopBtn = document.getElementById('tts-stop-btn');
        const statusP = document.getElementById('tts-status');

        if (typeof speechSynthesis === 'undefined') {
            statusP.textContent = 'Speech Synthesis API not supported in this browser.';
            [speakBtn, pauseBtn, resumeBtn, stopBtn, voiceSelect, rateSlider, pitchSlider].forEach(el => el.disabled = true);
            return;
        }
        
        function updateTTSButtons() {
            if (!ttsUtterance) { // No active utterance
                speakBtn.disabled = !textInput.value.trim() || ttsVoices.length === 0;
                pauseBtn.disabled = true;
                resumeBtn.disabled = true;
                stopBtn.disabled = true;
                return;
            }
            // Based on SpeechSynthesis state
            speakBtn.disabled = speechSynthesis.speaking || speechSynthesis.pending;
            pauseBtn.disabled = !speechSynthesis.speaking || speechSynthesis.paused;
            resumeBtn.disabled = !speechSynthesis.paused;
            stopBtn.disabled = !speechSynthesis.speaking && !speechSynthesis.paused;
        }


        function populateVoiceList() {
            ttsVoices = speechSynthesis.getVoices();
            voiceSelect.innerHTML = '';
            if (ttsVoices.length === 0) {
                voiceSelect.innerHTML = '<option>No voices available on this system.</option>';
                voiceSelect.disabled = true;
                updateTTSButtons();
                return;
            }
            voiceSelect.disabled = false;
            let defaultVoiceIndex = -1;
            ttsVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                if (voice.default) {
                    option.textContent += ' -- DEFAULT';
                    defaultVoiceIndex = index;
                }
                option.setAttribute('data-lang', voice.lang);
                option.setAttribute('data-name', voice.name);
                voiceSelect.appendChild(option);
            });
            if(defaultVoiceIndex > -1) voiceSelect.selectedIndex = defaultVoiceIndex;
            updateTTSButtons();
        }

        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }
        
        textInput.addEventListener('input', updateTTSButtons);
        rateSlider.addEventListener('input', () => { rateValueSpan.textContent = rateSlider.value; if (ttsUtterance) ttsUtterance.rate = parseFloat(rateSlider.value); });
        pitchSlider.addEventListener('input', () => { pitchValueSpan.textContent = pitchSlider.value; if (ttsUtterance) ttsUtterance.pitch = parseFloat(pitchSlider.value);});

        speakBtn.addEventListener('click', () => {
            if (!textInput.value.trim()) { statusP.textContent = "Please enter text to speak."; return; }
            if (speechSynthesis.speaking) speechSynthesis.cancel(); // Stop previous before starting new
            
            ttsUtterance = new SpeechSynthesisUtterance(textInput.value.trim());
            const selectedVoiceName = voiceSelect.selectedOptions[0].getAttribute('data-name');
            ttsUtterance.voice = ttsVoices.find(voice => voice.name === selectedVoiceName);
            ttsUtterance.pitch = parseFloat(pitchSlider.value);
            ttsUtterance.rate = parseFloat(rateSlider.value);
            
            ttsUtterance.onstart = () => { statusP.textContent = "Speaking..."; updateTTSButtons(); };
            ttsUtterance.onpause = () => { statusP.textContent = "Paused."; updateTTSButtons(); };
            ttsUtterance.onresume = () => { statusP.textContent = "Resumed speaking..."; updateTTSButtons(); };
            ttsUtterance.onend = () => { statusP.textContent = "Finished speaking."; ttsUtterance = null; updateTTSButtons(); };
            ttsUtterance.onerror = (e) => { statusP.textContent = "Error: " + e.error; ttsUtterance = null; updateTTSButtons(); };

            speechSynthesis.speak(ttsUtterance);
            updateTTSButtons();
        });
        pauseBtn.addEventListener('click', () => { if (speechSynthesis.speaking) speechSynthesis.pause(); updateTTSButtons(); });
        resumeBtn.addEventListener('click', () => { if (speechSynthesis.paused) speechSynthesis.resume(); updateTTSButtons(); });
        stopBtn.addEventListener('click', () => { if (speechSynthesis.speaking || speechSynthesis.paused) speechSynthesis.cancel(); /* onend will fire */ });
    }

    // 16. Speech to Text (Existing)
    function initSpeechToText() {
        const startBtn = document.getElementById('stt-start-btn');
        const stopBtn = document.getElementById('stt-stop-btn');
        const outputTextarea = document.getElementById('stt-output');
        const statusP = document.getElementById('stt-status');

        const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognitionAPI) {
            statusP.textContent = 'Speech Recognition API not supported in this browser.';
            startBtn.disabled = true;
            return;
        }

        recognition = new SpeechRecognitionAPI();
        recognition.continuous = true; 
        recognition.interimResults = true;
        recognition.lang = navigator.language || 'en-US'; 

        let finalTranscript = '';

        recognition.onstart = () => {
            sttIsListening = true;
            statusP.textContent = 'Listening... Speak now.';
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            finalTranscript = outputTextarea.value; // Preserve previous final text if any, for appending.
        };

        recognition.onresult = (event) => {
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTranscript += (finalTranscript.endsWith(" ") || finalTranscript === "" ? "" : " ") + event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }
            outputTextarea.value = finalTranscript + (interimTranscript ? (finalTranscript.endsWith(" ") || finalTranscript === "" ? "" : " ") + interimTranscript : "");
        };

        recognition.onerror = (event) => {
            let errorMsg = 'Error: ' + event.error;
            if (event.error === 'no-speech') errorMsg = 'No speech detected. Please try speaking louder or clearer.';
            else if (event.error === 'audio-capture') errorMsg = 'Microphone error. Ensure it is enabled and not in use by another app.';
            else if (event.error === 'not-allowed') errorMsg = 'Permission to use microphone was denied. Please enable it in browser settings.';
            statusP.textContent = errorMsg;
            sttIsListening = false; // Ensure state is correct even on error
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
        };

        recognition.onend = () => {
            sttIsListening = false;
            if (statusP.textContent === 'Listening... Speak now.') { // If ended without speech or error
                statusP.textContent = 'Speech recognition ended. Click Start to try again.';
            }
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
        };

        startBtn.addEventListener('click', () => {
            if (!sttIsListening) {
                outputTextarea.value = ''; // Clear for new session
                finalTranscript = '';
                try {
                    recognition.start();
                } catch (e) {
                    statusP.textContent = "Could not start recognition: " + e.message + ". Try again.";
                }
            }
        });
        stopBtn.addEventListener('click', () => { if (sttIsListening) recognition.stop(); });
        statusP.textContent = 'Click "Start Listening" to begin.';
    }

    // 17. JSON Formatter (Existing - added minify)
    function initJSONFormatter() {
        const inputArea = document.getElementById('jsonf-input');
        const outputArea = document.getElementById('jsonf-output');
        const formatBtn = document.getElementById('jsonf-format-btn');
        const minifyBtn = document.getElementById('jsonf-minify-btn');
        const copyBtn = document.getElementById('jsonf-copy-btn');
        const resultDiv = document.getElementById('jsonf-result');
        const errorP = document.getElementById('jsonf-error');

        function processJSON(minify = false) {
            const jsonString = inputArea.value.trim();
            errorP.textContent = '';
            resultDiv.style.display = 'none';

            if (!jsonString) {
                errorP.textContent = 'Input JSON cannot be empty.';
                return;
            }
            try {
                const jsonObj = JSON.parse(jsonString);
                outputArea.value = JSON.stringify(jsonObj, null, minify ? 0 : 2);
                resultDiv.style.display = 'block';
                 errorP.textContent = minify ? 'JSON minified successfully.' : 'JSON formatted successfully.';
            } catch (e) {
                errorP.textContent = 'Invalid JSON: ' + e.message;
                outputArea.value = '';
            }
        }
        formatBtn.addEventListener('click', () => processJSON(false));
        minifyBtn.addEventListener('click', () => processJSON(true));
        copyBtn.addEventListener('click', () => {
            if (outputArea.value) {
                navigator.clipboard.writeText(outputArea.value).then(() => {
                    errorP.textContent = 'Output copied to clipboard!';
                }).catch(err => { errorP.textContent = 'Failed to copy output.'; });
            }
        });
    }

    // 18. Unit Converter (Existing - added more units)
    function initUnitConverter() {
        const categorySelect = document.getElementById('uc-category');
        const fromUnitSelect = document.getElementById('uc-from-unit');
        const toUnitSelect = document.getElementById('uc-to-unit');
        const inputValueEl = document.getElementById('uc-input-value');
        const convertBtn = document.getElementById('uc-convert-btn');
        const resultDiv = document.getElementById('uc-result');
        const resultText = document.getElementById('uc-result-text');

        const unitsData = { // Expanded
            length: { name: "Length", baseUnit: "meter", units: { meter: { n: "Meter (m)", f: 1 }, kilometer: { n: "Kilometer (km)", f: 1000 }, centimeter: { n: "Centimeter (cm)", f: 0.01 }, millimeter: { n: "Millimeter (mm)", f: 0.001 }, mile: { n: "Mile (mi)", f: 1609.34 }, yard: { n: "Yard (yd)", f: 0.9144 }, foot: { n: "Foot (ft)", f: 0.3048 }, inch: { n: "Inch (in)", f: 0.0254 }, nauticalmile: { n: "Nautical Mile", f: 1852 } } },
            temperature: { name: "Temperature", units: { celsius: { n: "Celsius (°C)" }, fahrenheit: { n: "Fahrenheit (°F)" }, kelvin: { n: "Kelvin (K)" } },
                convert: (v, from, to) => { let C; if (from === to) return v; if (from === 'celsius') C = v; else if (from === 'fahrenheit') C = (v - 32) * 5/9; else if (from === 'kelvin') C = v - 273.15; else return NaN; if (to === 'celsius') return C; if (to === 'fahrenheit') return (C * 9/5) + 32; if (to === 'kelvin') return C + 273.15; return NaN; }
            },
            weight: { name: "Weight/Mass", baseUnit: "kilogram", units: { kilogram: { n: "Kilogram (kg)", f: 1 }, gram: { n: "Gram (g)", f: 0.001 }, milligram: { n: "Milligram (mg)", f: 0.000001 }, pound: { n: "Pound (lb)", f: 0.45359237 }, ounce: { n: "Ounce (oz)", f: 0.0283495231 }, stone: {n: "Stone (st)", f: 6.35029}, tonne: {n: "Tonne (t)", f: 1000} } },
            area: { name: "Area", baseUnit: "sqmeter", units: { sqmeter: {n: "Square Meter (m²)", f:1}, sqkm: {n: "Square Kilometer (km²)", f:1e6}, sqcm: {n: "Square Centimeter (cm²)", f:1e-4}, hectare: {n: "Hectare (ha)", f:1e4}, acre: {n: "Acre", f:4046.86}, sqmile: {n:"Square Mile (mi²)", f:2.59e6}, sqfoot: {n:"Square Foot (ft²)", f:0.092903} } },
            volume: { name: "Volume", baseUnit: "liter", units: { liter: {n:"Liter (L)", f:1}, milliliter: {n:"Milliliter (mL)", f:0.001}, cubmeter: {n:"Cubic Meter (m³)", f:1000}, gallonUS: {n:"US Gallon", f:3.78541}, quartUS: {n:"US Quart", f:0.946353}, pintUS: {n:"US Pint", f:0.473176}, cupUS: {n:"US Cup", f:0.236588}, flozUS: {n:"US Fluid Ounce", f:0.0295735} } },
            speed: { name: "Speed", baseUnit: "mps", units: { mps: {n:"Meter/second (m/s)", f:1}, kph: {n:"Kilometer/hour (km/h)", f:1/3.6}, mph: {n:"Mile/hour (mph)", f:0.44704}, knot: {n:"Knot (kn)", f:0.514444} } },
            time: { name: "Time", baseUnit: "second", units: { second: {n:"Second (s)", f:1}, millisecond: {n:"Millisecond (ms)", f:0.001}, minute: {n:"Minute (min)", f:60}, hour: {n:"Hour (hr)", f:3600}, day: {n:"Day", f:86400}, week: {n:"Week", f:604800}, year: {n:"Year (365d)", f:31536000} } },
        };

        function populateUnits(categoryKey) {
            fromUnitSelect.innerHTML = ''; toUnitSelect.innerHTML = '';
            const cat = unitsData[categoryKey];
            if (!cat) return;
            Object.keys(cat.units).forEach(uk => {
                [fromUnitSelect, toUnitSelect].forEach(sel => {
                    const opt = document.createElement('option');
                    opt.value = uk; opt.textContent = cat.units[uk].n; sel.appendChild(opt);
                });
            });
            if (Object.keys(cat.units).length > 1) toUnitSelect.selectedIndex = 1;
        }

        categorySelect.addEventListener('change', function() { populateUnits(this.value); resultDiv.style.display = 'none'; inputValueEl.value = ''; });
        convertBtn.addEventListener('click', function() {
            const catKey = categorySelect.value, fromKey = fromUnitSelect.value, toKey = toUnitSelect.value;
            const val = parseFloat(inputValueEl.value);
            if (isNaN(val)) { resultText.textContent = 'Invalid input value.'; resultDiv.style.display = 'block'; return; }

            const cat = unitsData[catKey]; let res;
            if (cat.convert) res = cat.convert(val, fromKey, toKey);
            else res = (val * cat.units[fromKey].f) / cat.units[toKey].f;
            
            let prec = 4; if (Math.abs(res) > 1e5 || (Math.abs(res) < 1e-3 && res !==0)) prec = 6;
            resultText.textContent = `${val} ${cat.units[fromKey].n.split('(')[0].trim()} = ${res.toPrecision(prec)} ${cat.units[toKey].n.split('(')[0].trim()}`;
            resultDiv.style.display = 'block';
        });
        populateUnits(categorySelect.value); // Initial
    }

    // 19. BMI Calculator (Existing)
    function initBMICalculator() {
        const heightInput = document.getElementById('bmi-height');
        const weightInput = document.getElementById('bmi-weight');
        const calculateBtn = document.getElementById('bmi-calculate-btn');
        const resultDiv = document.getElementById('bmi-result');
        const bmiValueText = document.getElementById('bmi-value-text');
        const bmiCategoryText = document.getElementById('bmi-category-text');

        calculateBtn.addEventListener('click', () => {
            const heightCm = parseFloat(heightInput.value);
            const weightKg = parseFloat(weightInput.value);

            if (isNaN(heightCm) || heightCm <= 0 || isNaN(weightKg) || weightKg <= 0) {
                bmiValueText.textContent = 'Please enter valid positive height and weight.';
                bmiCategoryText.textContent = '';
                resultDiv.style.display = 'block';
                return;
            }
            const heightM = heightCm / 100;
            const bmi = weightKg / (heightM * heightM);
            let category = '', color = 'var(--text-color)';

            if (bmi < 16) { category = 'Severe Thinness'; color = '#FF6B6B';}
            else if (bmi < 17) { category = 'Moderate Thinness'; color = '#FF8C42';}
            else if (bmi < 18.5) { category = 'Mild Thinness (Underweight)'; color = '#FFB347';}
            else if (bmi < 25) { category = 'Normal weight'; color = '#90EE90';} // LightGreen
            else if (bmi < 30) { category = 'Overweight'; color = '#FFB347';}
            else if (bmi < 35) { category = 'Obese Class I'; color = '#FF8C42';}
            else if (bmi < 40) { category = 'Obese Class II'; color = '#FF6B6B';}
            else { category = 'Obese Class III (Severely Obese)'; color = '#D32F2F';}


            bmiValueText.textContent = `Your BMI: ${bmi.toFixed(2)}`;
            bmiCategoryText.innerHTML = `Category: <strong style="color:${color};">${category}</strong>`;
            resultDiv.style.display = 'block';
        });
    }

    // 20. Timer/Stopwatch (Existing - added hours to timer)
    function initTimerStopwatch() {
        const timerSection = document.getElementById('ts-timer-section');
        const timerHoursInput = document.getElementById('ts-timer-hours');
        const timerMinutesInput = document.getElementById('ts-timer-minutes');
        const timerSecondsInput = document.getElementById('ts-timer-seconds');
        const timerDisplay = document.getElementById('ts-timer-display');
        const timerStartBtn = document.getElementById('ts-timer-start-btn');
        const timerPauseBtn = document.getElementById('ts-timer-pause-btn');
        const timerResetBtn = document.getElementById('ts-timer-reset-btn');

        const stopwatchSection = document.getElementById('ts-stopwatch-section');
        const stopwatchDisplay = document.getElementById('ts-stopwatch-display');
        const stopwatchStartBtn = document.getElementById('ts-stopwatch-start-btn');
        const stopwatchStopBtn = document.getElementById('ts-stopwatch-stop-btn');
        const stopwatchResetBtn = document.getElementById('ts-stopwatch-reset-btn');
        const stopwatchLapBtn = document.getElementById('ts-stopwatch-lap-btn');
        const lapsList = document.getElementById('ts-laps-list');

        const showTimerBtn = document.getElementById('ts-show-timer-btn');
        const showStopwatchBtn = document.getElementById('ts-show-stopwatch-btn');

        showTimerBtn.addEventListener('click', () => { timerSection.style.display = 'block'; stopwatchSection.style.display = 'none'; if (stopwatchRunning) stopwatchStopBtn.click();});
        showStopwatchBtn.addEventListener('click', () => { timerSection.style.display = 'none'; stopwatchSection.style.display = 'block'; if (timerRunning) timerPauseBtn.click();});

        function updateTimerDisplayHTML() {
            const h = Math.floor(timerTotalSeconds / 3600);
            const m = Math.floor((timerTotalSeconds % 3600) / 60);
            const s = timerTotalSeconds % 60;
            timerDisplay.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }
        function setTimerFromInputs() {
            let h = parseInt(timerHoursInput.value) || 0;
            let m = parseInt(timerMinutesInput.value) || 0;
            let s = parseInt(timerSecondsInput.value) || 0;
            timerTotalSeconds = (h * 3600) + (m * 60) + s;
            if (timerTotalSeconds < 0) timerTotalSeconds = 0;
            updateTimerDisplayHTML();
        }
        [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(inp => inp.addEventListener('change', setTimerFromInputs));

        timerStartBtn.addEventListener('click', () => {
            if (timerRunning) return;
            if (timerTotalSeconds <= 0) { setTimerFromInputs(); if (timerTotalSeconds <= 0) { alert("Set duration > 0."); return; } }
            timerRunning = true;
            [timerHoursInput, timerMinutesInput, timerSecondsInput, timerStartBtn].forEach(el => el.disabled = true);
            timerPauseBtn.disabled = false;
            timerInterval = setInterval(() => {
                timerTotalSeconds--; updateTimerDisplayHTML();
                if (timerTotalSeconds <= 0) {
                    clearInterval(timerInterval); timerRunning = false; alert('Timer finished!');
                    [timerHoursInput, timerMinutesInput, timerSecondsInput, timerStartBtn].forEach(el => el.disabled = false);
                    timerPauseBtn.disabled = true; setTimerFromInputs();
                }
            }, 1000);
        });
        timerPauseBtn.addEventListener('click', () => {
            if (!timerRunning) return; clearInterval(timerInterval); timerRunning = false;
            timerStartBtn.disabled = false; timerPauseBtn.disabled = true;
        });
        timerResetBtn.addEventListener('click', () => {
            clearInterval(timerInterval); timerRunning = false;
            timerHoursInput.value = "0"; timerMinutesInput.value = "5"; timerSecondsInput.value = "0";
            setTimerFromInputs();
            [timerHoursInput, timerMinutesInput, timerSecondsInput, timerStartBtn].forEach(el => el.disabled = false);
            timerPauseBtn.disabled = true;
        });

        function formatSWTime(ms) {
            const h = Math.floor(ms / 3600000);
            const m = Math.floor((ms % 3600000) / 60000);
            const s = Math.floor((ms % 60000) / 1000);
            const dms = Math.floor((ms % 1000) / 10); // centiseconds
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(dms).padStart(2,'0')}`;
        }
        function updateSWDisplayHTML() { stopwatchDisplay.textContent = formatSWTime(stopwatchElapsedTime); }
        stopwatchStartBtn.addEventListener('click', () => {
            if (stopwatchRunning) return; stopwatchRunning = true;
            stopwatchStartTime = Date.now() - stopwatchElapsedTime;
            stopwatchStartBtn.disabled = true; stopwatchStopBtn.disabled = false; stopwatchLapBtn.disabled = false;
            stopwatchInterval = setInterval(() => { stopwatchElapsedTime = Date.now() - stopwatchStartTime; updateSWDisplayHTML(); }, 10);
        });
        stopwatchStopBtn.addEventListener('click', () => {
            if (!stopwatchRunning) return; clearInterval(stopwatchInterval); stopwatchRunning = false;
            stopwatchStartBtn.disabled = false; stopwatchStopBtn.disabled = true;
        });
        stopwatchResetBtn.addEventListener('click', () => {
            clearInterval(stopwatchInterval); stopwatchRunning = false; stopwatchElapsedTime = 0; stopwatchLaps = [];
            updateSWDisplayHTML(); lapsList.innerHTML = '';
            stopwatchStartBtn.disabled = false; stopwatchStopBtn.disabled = true; stopwatchLapBtn.disabled = true;
        });
        stopwatchLapBtn.addEventListener('click', () => {
            if (stopwatchElapsedTime > 0) {
                stopwatchLaps.push(stopwatchElapsedTime);
                const li = document.createElement('li');
                li.textContent = `Lap ${stopwatchLaps.length}: ${formatSWTime(stopwatchElapsedTime)}`;
                lapsList.insertBefore(li, lapsList.firstChild);
            }
        });
        setTimerFromInputs(); // Initial timer display
    }
    
    // Helper to format file size
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.max(0, Math.floor(Math.log(bytes) / Math.log(k))); // Handle bytes < 1KB
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

</script>

<!-- Adsterra Native Banner Ad: Bottom -->
<div style="text-align: center; margin: 20px 0;">
<script async="async" data-cfasync="false" src="//pl26775252.profitableratecpm.com/a555bed94aadc7d548b237ce9fd3f213/invoke.js"></script>
<div id="container-a555bed94aadc7d548b237ce9fd3f213"></div>
</div>


<!-- Telegram Join Button -->
<div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/Multitoolhub" target="_blank" style="display: inline-block; background-color: #0088cc; color: white; padding: 10px 20px; border-radius: 5px; text-decoration: none; font-weight: bold;">
        Join Our Telegram
    </a>
</div>

</body>
</html>